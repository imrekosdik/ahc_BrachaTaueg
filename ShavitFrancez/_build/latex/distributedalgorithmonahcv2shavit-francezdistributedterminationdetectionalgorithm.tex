%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}

\usepackage{nbsphinx}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Distributed Algorithm on AHCv2: Shavit\sphinxhyphen{}Francez Distributed Termination Detection Algorithm}
\date{May 11, 2024}
\release{V1.0.0}
\author{İmre Kosdik}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}
\label{\detokenize{docs/ShavitFrancez/ShavitFrancez:shavitfrancezalg}}\label{\detokenize{docs/ShavitFrancez/ShavitFrancez::doc}}
\sphinxstepscope


\section{Abstract}
\label{\detokenize{docs/ShavitFrancez/abstract:abstract}}\label{\detokenize{docs/ShavitFrancez/abstract::doc}}
\sphinxAtStartPar
A computation in a distributed algorithm terminates when the algorithm reaches a state where no potential applicable steps exist. In distributed systems, determining whether a particular computation has terminated is a crucial need because the execution of other computations may depend on the completion of the execution. Because the processes in a distributed system do not know the global state of the system and do not share any global clock, inferring if a distributed computation has ended is a challenging problem. The {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} is a fundamental termination detection algorithm that addresses these issues, ensuring that the system reaches a consistent state where all the processes complete their computations before proceeding with other tasks. Implementing the {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}}, along with analyzing the message and time complexity by running the algorithm on different network topologies and various numbers of nodes, provides valuable insights on the algorithm’s efficiency and applicability over real\sphinxhyphen{}world distributed systems.

\sphinxstepscope


\section{Introduction}
\label{\detokenize{docs/ShavitFrancez/introduction:introduction}}\label{\detokenize{docs/ShavitFrancez/introduction::doc}}
\sphinxAtStartPar
When a problem requires more than one process to be solved, distributed systems are a good candidate. These processes work together to solve subproblems. Therefore, it is crucial to identify when a process has completed its execution because its output is used as input to another process to continue its execution. Termination detection in distributed computing is a challenging task in distributed systems because processes are unaware of the global state of the system due to communication delays, and there is no shared global system.

\sphinxAtStartPar
Termination detection algorithms have a significant role in ensuring a consistent state where all processes complete their computations and are ready to proceed with the upcoming tasks. Achieving a consistent state also preserves the correctness of the system. Termination detection can also take part in efficient resource management by releasing not\sphinxhyphen{}needed resources. Additionally, efficient resource management may be beneficial in preventing deadlocks since their primary cause is indefinitely waiting to acquire resources.

\sphinxAtStartPar
Termination is a property of the global state of distributed computing. However, due to the decentralized and asynchronous nature of distributed systems, acquiring the global state of the system is a significant challenge. Since termination detection algorithms rely on additional control messages, the message overhead can thoroughly impact the system’s performance. Also, as the distributed system expands, the complexity and overhead of maintaining the algorithm can result in scalability issues. Additionally, designing algorithms such that the underlying computation does not interfere with the ongoing executions is another challenge.

\sphinxAtStartPar
{\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} is an effective way to detect termination without interfering with the overall execution of the distributed system. The algorithm doesn’t rely on synchronous communication, simplifying the design and implementation of the system. In contrast to the increasing number of nodes, the message\sphinxhyphen{}sharing overhead from the algorithm remains low, which means it has less impact on the system’s performance. In this paper, we aim to comprehensively explain the implementation details of {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} and present the results of experiments we conducted on the algorithm related to its time and message complexity.

\sphinxAtStartPar
We contribute to the field of distributed systems by:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Implementating {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} on the AHCv2 platform. We explain the implementation details in Section 1.3.

\item {} 
\sphinxAtStartPar
Conducting experiments on the algorithm over different network topologies and node counts. We discuss the experiment setup and results in Section 1.4

\end{itemize}

\sphinxstepscope


\section{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}
\label{\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezalg}}\label{\detokenize{docs/ShavitFrancez/algorithm::doc}}

\subsection{Background and Related Work}
\label{\detokenize{docs/ShavitFrancez/algorithm:background-and-related-work}}
\sphinxAtStartPar
Global termination in a distributed system occurs when all processes reach the local termination state, no messages are in transit, and processes do not send or receive any message. Local termination is the state where the process completed its execution, meaning it is passive (idle) and is ready to continue its computation upon receiving any message. A process is active when it is performing some computation. In a distributed system, only the active processes can send messages. Therefore, a computation in a distributed system terminates when all its processes are idle.

\sphinxAtStartPar
The primary consideration behind the termination detection algorithms is adding a control algorithm to the system running to detect whether the basic algorithm has reached a termination state. The basic algorithm is the one currently running in the distributed system. Initiators of the basic algorithm are active processes and can trigger the execution of the control algorithm. The control algorithm consists of the termination detection and the announcement phases. The messages that the control algorithm sends or receives are control messages. Ideally, the termination detection algorithm should not need additional communication channels to send or receive its control messages, and should not interfere with the basic algorithm running on the system.

\sphinxAtStartPar
{\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} \sphinxcite{docs/ShavitFrancez/algorithm:shavitfrancez1986} is the generalization of Dijkstra\sphinxhyphen{}Scholten Termination Detection Algorithm \sphinxcite{docs/ShavitFrancez/algorithm:dijkstrasholten1980} for distributed systems. In Dijkstra\sphinxhyphen{}Scholten Algorithm, the initiator of the basic algorithm maintains a tree of active processes. If a process makes another process active by sending a message, that process joins the tree as a child of the process. A process can only leave the tree if it transitions to passive state and it has no children in the tree. Once the tree becomes empty, the initiator announces the termination. {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}}}} \sphinxcite{docs/ShavitFrancez/algorithm:shavitfrancez1986} maintains a forest instead of a single tree due to the nature of the distributed system. Each initiator maintains its tree and constitutes it to the forest. The condition for a process to join a tree is that it is not already a member of any of the trees in the forest. Other than that, the algorithm continues as in the Dijkstra\sphinxhyphen{}Scholten Algorithm. Instead, it starts a wave in which only those processes not part of a tree participate. Because each initiator is only aware of the emptiness of its tree, an empty tree does not guarantee that the whole forest is empty. The wave algorithm ensures that all the trees in the forest collapse before announcing termination. Once the wave decides, the initiator can then announce the termination. A wave algorithm is not complete unless all the processes take part in its execution. Following this property, the algorithm ensures that if none of the waves started by the processes are complete because a process refuses to take part, the initiator maintaining the last tree to be empty will start a wave that eventually decides and announces the termination. \sphinxcite{docs/ShavitFrancez/algorithm:fokking2013}

\sphinxAtStartPar
The wave algorithm we choose for the implementation in {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}}}}  is {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:echoalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Echo Algorithm}}}} \sphinxcite{docs/ShavitFrancez/algorithm:fokking2013}. The {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:echoalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Echo Algorithm}}}} initiator begins by sending messages to all of its neighbors. If a non\sphinxhyphen{}initiator receives a message for the first time, it sets its parent as the sender process and sends a message to all its neighbors except its parent. After receiving messages from all its neighbors, the non\sphinxhyphen{}initiator notifies its parent. Finally, the initiator receives messages from all its neighbors and decides.


\subsection{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm: Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}
\label{\detokenize{docs/ShavitFrancez/algorithm:shavit-francez-termination-detection-algorithm-shavitfrancezalg}}
\sphinxAtStartPar
The {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}}}} is proposed by Nir Shavit and Nissim Francez to detect termination in the distributed system algorithms. General flow of execution of the algorithm is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
If a process is the initiator of the basic algorithm, it sets its active property to true, indicating that it is doing some computation at the time. (Line 5)

\item {} 
\sphinxAtStartPar
If a process sends a basic message while executing the basic algorithm, then it increases its number of children by 1, because the process that is sent message becomes its children. (Line 8)

\item {} 
\sphinxAtStartPar
If a process receives a basic message while it is passive, then it becomes active (Line 12) and sets its parent to the process sending the basic message (Line 13). If it was already active, then it informs the sending process with an ACKNOWLEDGE message. (Line 15)

\item {} 
\sphinxAtStartPar
If a process receives an ACKNOWLEDGE message, it decreases its number of children by 1 (Line 19), calls the LeaveTree procedure. (Line 20)

\item {} 
\sphinxAtStartPar
If at some point a process becomes passive then it sets its active property to false (Line 23), calls the LeaveTree procedure. (Line 24)

\item {} 
\sphinxAtStartPar
Inside the LeaveTree procedure, a passive process with no children sends its parent an ACKNOWLEDGE message (Line 29), and then sets its parent to None (Line 30).

\item {} 
\sphinxAtStartPar
If a passive process with no children has no parent at all, it starts a wave inside the LeaveTree procedure. (Line 32).

\item {} 
\sphinxAtStartPar
A a passive process with no children receiving a wave message acts as what the wave algorithm dictates (Line 37) and if the wave algorithm decides, it announces termination. (Line 38)

\end{enumerate}
\sphinxSetupCaptionForVerbatim{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}
\def\sphinxLiteralBlockLabel{\label{\detokenize{docs/ShavitFrancez/algorithm:id12}}\label{\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
bool active\PYGZlt{}p\PYGZgt{} // set when p becomes active, and reset when p becomes passive
nat cc\PYGZlt{}p\PYGZgt{} // keeps track of the number of children of p in its tree
proc parent\PYGZlt{}p\PYGZgt{} // the parent of p in a tree in the forest

if p is an initiator then
   active\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} true
end if

if p sends a basic message then
   cc\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} cc\PYGZlt{}p\PYGZgt{} + 1
end if

if p receives a basic message from a neighbor q then
   if active\PYGZlt{}p\PYGZgt{} = false then
      active\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} true
      parent\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} q
   else
      send \PYGZlt{}ack\PYGZgt{} to q
   end if
end if

if p receives \PYGZlt{}ack\PYGZgt{}
   cc\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} cc\PYGZlt{}p\PYGZgt{} \PYGZhy{} 1
   perform procedure LeaveTree\PYGZlt{}p\PYGZgt{}
end if

if p becomes passive
   active\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} false
   perform procedure LeaveTree\PYGZlt{}p\PYGZgt{};
end if

Procedure LeaveTree\PYGZlt{}p\PYGZgt{}
   if active\PYGZlt{}p\PYGZgt{} = false and cc\PYGZlt{}p\PYGZgt{} = 0 then
       if parent\PYGZlt{}p\PYGZgt{} != ┴ then
             send \PYGZlt{}ack\PYGZgt{} to parent\PYGZlt{}p\PYGZgt{}
             parent\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} ┴
       else
         start a wave, tagged with p
   end if
end if

if p receives a wave message then
   if active\PYGZlt{}p\PYGZgt{} = false and cc\PYGZlt{}p\PYGZgt{} = 0 then
       act according to the wave algorithm
       in the case of a decive event, call Announce
   end if
end if
\end{sphinxVerbatim}


\subsection{Echo Algorithm:}
\label{\detokenize{docs/ShavitFrancez/algorithm:echo-algorithm}}
\sphinxAtStartPar
The {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:echoalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Echo Algorithm}}}} \sphinxcite{docs/ShavitFrancez/algorithm:fokking2013} takes part in making sure that all the trees in the forest collapsed and thus, concluding that the basic algorithm terminated. Since this paper focuses on the implementation details of the {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}}}}, we do not explicitly describe the pseudocode we provided for the wave algorithm. We only add the pseudocode here because we make use of this algorithm while implementing the {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Termination Detection Algorithm}}}}.
\sphinxSetupCaptionForVerbatim{Echo Algorithm}
\def\sphinxLiteralBlockLabel{\label{\detokenize{docs/ShavitFrancez/algorithm:id13}}\label{\detokenize{docs/ShavitFrancez/algorithm:echoalgorithm}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
nat received\PYGZlt{}p\PYGZgt{};
proc parent\PYGZlt{}p\PYGZgt{};

if p is the initiator then
   send \PYGZlt{}wave\PYGZgt{} to each r in Neighbors\PYGZlt{}p\PYGZgt{}
end if

if p receives a \PYGZlt{}wave\PYGZgt{} from neighbor q then
   received\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} received\PYGZlt{}p\PYGZgt{} + 1
   if parent\PYGZlt{}p\PYGZgt{} != ┴ and p is a non\PYGZhy{}initiator then
       parent\PYGZlt{}p\PYGZgt{} \PYGZlt{}\PYGZhy{} q
       if |Neighbors\PYGZlt{}p\PYGZgt{}| \PYGZgt{} 1 then
          send \PYGZlt{}wave\PYGZgt{} to each r in Neighbors\PYGZlt{}p\PYGZgt{}\PYGZbs{}\PYGZob{}q\PYGZcb{}
       else
          send \PYGZlt{}wave\PYGZgt{} to q
       end if
   else if received\PYGZlt{}p\PYGZgt{} = |Neighbors\PYGZlt{}p\PYGZgt{}| then
       if parent\PYGZlt{}p\PYGZgt{} != ┴ then
          send \PYGZlt{}wave\PYGZgt{} to parent\PYGZlt{}p\PYGZgt{}
       else
          decide
       end if
   end if
end if
\end{sphinxVerbatim}


\subsection{Example With Terminating Distributed System Algorithm}
\label{\detokenize{docs/ShavitFrancez/algorithm:example-with-terminating-distributed-system-algorithm}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=766\sphinxpxdimen,height=558\sphinxpxdimen]{{shavit_step1}.png}
\sphinxfigcaption{Step 1}\label{\detokenize{docs/ShavitFrancez/algorithm:id14}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=766\sphinxpxdimen,height=558\sphinxpxdimen]{{shavit_step2}.png}
\sphinxfigcaption{Step 2}\label{\detokenize{docs/ShavitFrancez/algorithm:id15}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=766\sphinxpxdimen,height=558\sphinxpxdimen]{{shavit_step3}.png}
\sphinxfigcaption{Step 3}\label{\detokenize{docs/ShavitFrancez/algorithm:id16}}\end{sphinxfigure-in-table}\relax
\\
\sphinxhline\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=766\sphinxpxdimen,height=558\sphinxpxdimen]{{shavit_step4}.png}
\sphinxfigcaption{Step 4}\label{\detokenize{docs/ShavitFrancez/algorithm:id17}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=766\sphinxpxdimen,height=558\sphinxpxdimen]{{shavit_step5}.png}
\sphinxfigcaption{Step 5}\label{\detokenize{docs/ShavitFrancez/algorithm:id18}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=766\sphinxpxdimen,height=558\sphinxpxdimen]{{shavit_step6}.png}
\sphinxfigcaption{Step 6}\label{\detokenize{docs/ShavitFrancez/algorithm:id19}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Assume that there are three processes p, q, r in an undirected network. One way to execute the {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
At the start, the initiators p and q both send a basic message to r, and set cc\textless{}p\textgreater{} and cc\textless{}q\textgreater{} to 1. Next, p and q become passive.(See Figure 1)

\item {} 
\sphinxAtStartPar
Upon receipt of the basic message from p, r becomes active and makes p its parent. Next, r receives the basic message from q, and sends back an acknowledgment, which causes q to decrease cc\textless{}q\textgreater{} to 0.(See Figure 2)

\item {} 
\sphinxAtStartPar
Since q became passive as the root of a tree, and cc\textless{}q\textgreater{} = 0, it starts a wave. This wave does not complete, because p and r refuse to participate.(See Figure 3)

\item {} 
\sphinxAtStartPar
r sends a basic message to q, and sets cc\textless{}r\textgreater{} to 1. Next, r becomes passive.(See Figure 4)

\item {} 
\sphinxAtStartPar
Upon receipt of the basic message from r, q becomes active, and makes r its parent. Next, q becomes passive, and sends an acknowledgment to its parent r, which causes r to decrease cc\textless{}r\textgreater{} to 0. Since r is passive and cc\textless{}r\textgreater{} = 0, it sends an acknowledgment to its parent p, which causes p to decrease cc\textless{}p\textgreater{} to 0.(See Figure 5)

\item {} 
\sphinxAtStartPar
Since p became passive as the root of a tree, and cc\textless{}p\textgreater{} = 0, it starts a wave. This wave completes, so that p calls Announce.(See Figure 6)

\end{enumerate}


\subsection{Example With Non\sphinxhyphen{}Terminating Distributed System Algorithm}
\label{\detokenize{docs/ShavitFrancez/algorithm:example-with-non-terminating-distributed-system-algorithm}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=957\sphinxpxdimen,height=481\sphinxpxdimen]{{shavit_ex2_step1}.png}
\sphinxfigcaption{Step 1}\label{\detokenize{docs/ShavitFrancez/algorithm:id20}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=957\sphinxpxdimen,height=481\sphinxpxdimen]{{shavit_ex2_step2}.png}
\sphinxfigcaption{Step 2}\label{\detokenize{docs/ShavitFrancez/algorithm:id21}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=957\sphinxpxdimen,height=481\sphinxpxdimen]{{shavit_ex2_step3}.png}
\sphinxfigcaption{Step 3}\label{\detokenize{docs/ShavitFrancez/algorithm:id22}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Assume that there are three processes p, q, r in an undirected network. One way to execute the {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}} is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
At the start, the initiators p and r both send a basic message to q, and set cc\textless{}p\textgreater{} and cc\textless{}r\textgreater{} to 1. (See Figure 7)

\item {} 
\sphinxAtStartPar
Upon receipt of the basic message from p, q becomes active and makes p its parent. Next, q receives the basic message from r, and sends back an acknowledgment, which causes r to decrease cc\textless{}r\textgreater{} to 0. (See Figure 8)

\item {} 
\sphinxAtStartPar
Next, r becomes passive.

\item {} 
\sphinxAtStartPar
Since r became passive as the root of a tree, and cc\textless{}r\textgreater{} = 0, it starts a wave. This wave does not complete, because p and q refuse to participate.(See Figure 9)

\item {} 
\sphinxAtStartPar
Since neither p nor q becomes passive at some point, the algorithm cannot complete the wave and cannot announce termination.

\end{enumerate}


\subsection{Correctness}
\label{\detokenize{docs/ShavitFrancez/algorithm:correctness}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Safety}: The \sphinxstyleemphasis{Announce} is called when a decision occurs in the wave algorithm. This implies that each process p has sent a wave message or has decided, and the algorithm implies that cc\textless{}p\textgreater{} was 0 when p did so. No action makes cc\textless{}p\textgreater{} more than 0 again, so (for each p) cc\textless{}p\textgreater{} is 0 when \sphinxstyleemphasis{Announce} is called. \sphinxcite{docs/ShavitFrancez/algorithm:tel2001}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Liveness}: Assume that the basic computation has terminated. Within a finite number of steps the termination\sphinxhyphen{}detection algorithm reaches a terminal configuration, and as in the correctness statement below it can be shown that in this configuration the forest is empty. Consequently, all events of the wave are enabled in every process, and that the configuration is terminal now implies that all events of the wave have been executed, including at least one decision, which caused a call to \sphinxstyleemphasis{Announce}. \sphinxcite{docs/ShavitFrancez/algorithm:tel2001}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Correctness}: Define S to be the sum of all cc\textless{}p\textgreater{} for each process p. Initially S is zero, S is incremented when a basic message is sent, S is decremented when a control message is received, and S is never negative. This implies that the number of control messages never exceeds the number of basic messages in any computation. \sphinxcite{docs/ShavitFrancez/algorithm:tel2001}

\end{enumerate}


\subsection{Complexity}
\label{\detokenize{docs/ShavitFrancez/algorithm:complexity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/ShavitFrancez/algorithm:shavitfrancezterminationdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Shavit\sphinxhyphen{}Francez Algorithm}}}}: The worst case message complexity  is O(M + W) where M is the number of the messages sent by the underlying computation and W is a message exchange complexity of the wave algorithm, which is 2E for {\hyperref[\detokenize{docs/ShavitFrancez/algorithm:echoalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Echo Algorithm}}}} where E is. \sphinxcite{docs/ShavitFrancez/algorithm:tel2001}

\item {} 
\sphinxAtStartPar
{\hyperref[\detokenize{docs/ShavitFrancez/algorithm:echoalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Echo Algorithm}}}}: The message complexity is O(2E), where E is the number of edges. \sphinxcite{docs/ShavitFrancez/algorithm:fokking2013}

\end{enumerate}

\sphinxstepscope


\section{Implementation, Results and Discussion}
\label{\detokenize{docs/ShavitFrancez/results:implementation-results-and-discussion}}\label{\detokenize{docs/ShavitFrancez/results::doc}}

\subsection{Implementation and Methodology}
\label{\detokenize{docs/ShavitFrancez/results:implementation-and-methodology}}
\sphinxAtStartPar
We utilized the Python (version 3.12) scripting language and the Ad\sphinxhyphen{}Hoc Computing (adhoccomputing) library while implementing the Shavit\sphinxhyphen{}Francez Termination Detection Algorithm. We also employed the networkx library to generate various network topologies and the matplotlib library to visualize them. Each component in the topology can be the initiator for the termination detection algorithm. It is up to us which component to choose the initiator/initiators. After that, we must send an event to the initiators to execute the termination detection algorithm. Either initiator components can send the event to themselves, or other non\sphinxhyphen{}initator nodes can send it to the initiators. Since termination detection is the algorithm that runs on top of the basic algorithm running in the system, we needed to simulate a basic algorithm by creating additional messages that we could send to the component externally. We use “\sphinxstyleemphasis{BECOMEPASSIVE}” message to simulate processes finishing their execution and “\sphinxstyleemphasis{SENDBASICMESSAGE}” to simulate messages that the basic algorithm exchanges on its execution. An important consideration is that one can only send these messages if the process is active. Another consideration is that, the components need to be aware of who is executing the control algorithm. Therefore, the process starting the algorithm send a message to its neighbors indicating that it is the initiator for this execution.

\sphinxAtStartPar
For a distributed system in that its processes never become passive, we should expect that the algorithm does not announce the termination and, therefore, no output in the command prompt. As an example, we can consider a system with deadlocks. Since none of the processes can continue because they need resources from others, the algorithm cannot announce the termination. To create this scenario, we could think that the “SENDBASICMESSAGE” event acts as a “REQUEST” and create a cyclic graph. In other cases, sending a “BECOMEPASSIVE” event to a process acts as if the process finishing its execution, and we should see that the algorithm announces the termination in the commant prompt.

\sphinxAtStartPar
We implemented both the Echo Algorithm and the Shavit\sphinxhyphen{}Francez Termination Detection Algorithm by employing the pseudocode descriptions given in \sphinxcite{docs/ShavitFrancez/algorithm:fokking2013}. We used the same message types given in the descriptions to achieve the message passing between the components. The make the component who is the initiator of the basic algorithm send itself “DETECTTERMINATION” message to trigger the algorithm. After that, depending on the basic\sphinxhyphen{}messages exchanged between the processes and the status of the processes, the algorithm announces the termination.


\subsection{Results}
\label{\detokenize{docs/ShavitFrancez/results:results}}
\sphinxAtStartPar
In order to evaluate the message complexity of the Shavit\sphinxhyphen{}Francez Termination Detection Algorithm, we designed three different experiments. For the first experiment, we generate ring topologies with various number of node counts. The node with the first index becomes the initiator for the algorithm. Each node in the topology sends basic messages to all of its neighbors and then becomes passive. According to this configuration, we execute the algorithm for 2, 3, 5, 10, 20, 30, 50, 100 and 500 number of nodes and examine how many wave messages and basic messages are exchanged along with time it takes to complete the execution.

\sphinxAtStartPar
For a ring topology, if there are n number of nodes, then there exists n number of edges in the topology. On the table, we observe that the number of exchanged wave messages is exactly two terminates the number of edges. That means, it is consistent with the message complexity of the Echo Algorithm, which is O(2E). Since each node sends basic message to each of its neighbors, then there should be 2 * n basic messages exchanged in the topology. So, the results we get gives us the complexity of the underlying computation, which is O(M), where M is 2 * n. We also observe that, the time it takes to complete the execution of the algorithm is directly proportional to the number of nodes in the topology.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Message Complexity Analysis of Termination Detection Algorithm on a Ring Topology}\label{\detokenize{docs/ShavitFrancez/results:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{25}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Node Count
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Time Elapsed Until Termination
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number of Exchanged Messages
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
2
&
\sphinxAtStartPar
1.207543134689331
&
\sphinxAtStartPar
2 (wave) + 2 (basic)
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
1.5333149433135986
&
\sphinxAtStartPar
10 (wave) + 10 (basic)
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
2.045008897781372
&
\sphinxAtStartPar
20 (wave) + 20 (basic)
\\
\sphinxhline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
3.0964579582214355
&
\sphinxAtStartPar
40 (wave) + 40 (basic)
\\
\sphinxhline
\sphinxAtStartPar
30
&
\sphinxAtStartPar
4.135018825531006
&
\sphinxAtStartPar
60 (wave) + 60 (basic)
\\
\sphinxhline
\sphinxAtStartPar
50
&
\sphinxAtStartPar
6.216088056564331
&
\sphinxAtStartPar
100 (wave) + 100 (basic)
\\
\sphinxhline
\sphinxAtStartPar
100
&
\sphinxAtStartPar
11.443176984786987
&
\sphinxAtStartPar
200 (wave) + 200 (basic)
\\
\sphinxhline
\sphinxAtStartPar
500
&
\sphinxAtStartPar
53.18007707595825
&
\sphinxAtStartPar
1000 (wave) + 1000 (basic)
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=500\sphinxpxdimen,height=311\sphinxpxdimen]{{exchanged_messages}.png}
\sphinxfigcaption{The Relationship Between Node Count and Number Of Exchanged Messages}\label{\detokenize{docs/ShavitFrancez/results:id3}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=500\sphinxpxdimen,height=311\sphinxpxdimen]{{time_elapsed}.png}
\sphinxfigcaption{The Relationship Between the Node Count and the Elapsed Time}\label{\detokenize{docs/ShavitFrancez/results:id4}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
For the second experiment, we generate complete topologies with different node counts. As in the first configuration, there is one initiator and each node sends basic message to all of its neighbors. After executing the algorithm for topologies with 2,5, 10, 20, 30, 40 and 50 node counts, we conclude that, the same relationship between the number of edges and the exchanged messages exist in this experiment as well. It seems that, there are not much difference between elapsed time of this experiment with the first experiment. Note that, we could not execute the algorithm for node counts larger than 40 because adhoccomputing library could not create new threads.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Message Complexity Analysis of Termination Detection Algorithm on a Complete Topology}\label{\detokenize{docs/ShavitFrancez/results:id5}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{50}\X{25}{50}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Node Count
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Time Elapsed Until Termination
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
2
&
\sphinxAtStartPar
1.211822748184204
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
1.5393249988555908
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
2.0759570598602295
\\
\sphinxhline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
3.2077481746673584
\\
\sphinxhline
\sphinxAtStartPar
30
&
\sphinxAtStartPar
4.605236291885376
\\
\sphinxhline
\sphinxAtStartPar
40
&
\sphinxAtStartPar
10.92475700378418
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
For the last experiment, since more than one node can trigger the termination detection algorithm, we analyze the message complexity of a complete topology of 10 nodes with 1 to 5 number of initiators. Other than that, the experiment setup is exactly like that in the first and second experiments. There are 90 wave messages and 90 basic messages exchanged between the nodes. Each of the initiator is able to announce termination so we present the best time elapsed among different initiator results. To conclude, even though the number of initiators change, number of exchanged messages stay the same. Since each initiator forms its own forest and the number of messages do not change, the elapsed time does not get affected by the initiator count.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Message Complexity Analysis of Termination Detection Algorithm on a Complete Topology with Different Number of Initiators}\label{\detokenize{docs/ShavitFrancez/results:id6}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{50}\X{25}{50}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Initiator Count
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Time Elapsed Until Termination
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1
&
\sphinxAtStartPar
2.073668956756592
\\
\sphinxhline
\sphinxAtStartPar
2
&
\sphinxAtStartPar
2.172826051712036
\\
\sphinxhline
\sphinxAtStartPar
3
&
\sphinxAtStartPar
2.1762309074401855
\\
\sphinxhline
\sphinxAtStartPar
4
&
\sphinxAtStartPar
2.169590950012207
\\
\sphinxhline
\sphinxAtStartPar
5
&
\sphinxAtStartPar
2.158134937286377
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Discussion}
\label{\detokenize{docs/ShavitFrancez/results:discussion}}
\sphinxAtStartPar
We run three distinct experiments to analyze the message and time complexity of the algorithm. To distinguish between the experiments, we did not change the underlying computation, that is, we make each process send each of its neighbors basic messages. By not changing the underlying computation, we could observe the changes in the elapsed time over different topologies. For a small number of nodes, less than 50, we observe that the topology does not affect the time elapsed to finish executing the algorithm. Unfortunately, due to the nature of the ad\sphinxhyphen{}hoc computing library, we could not compare two different topologies over a large number of nodes. Also, while running experiments, we had to add delays between the events because we observed that, in the absence of the delays, we could not see the exchange of all the messages we sent. To conduct experiments, we created an event to simulate some basic algorithms running in our topologies. Since the expectation is that the basic algorithm is to run separately from the control algorithm, having to add a specific function to pass basic messages to components may conflict with it. The experiment results demonstrated that the complexity of the underlying computation is proportional to the number of edges in the topology in all experiments. For the wave algorithm, our experiment results coincide with the worst\sphinxhyphen{}case complexity of the Echo Algorithm. To sum up, we see that the experiment results are in line with the worst\sphinxhyphen{}case complexity of the termination detection algorithm.

\sphinxstepscope


\section{Conclusion}
\label{\detokenize{docs/ShavitFrancez/conclusion:conclusion}}\label{\detokenize{docs/ShavitFrancez/conclusion::doc}}
\sphinxAtStartPar
The Shavit\sphinxhyphen{}Francez algorithm is a reliable and versatile solution for detecting the termination of distributed computations across various network topologies. In our research, we have emphasized the importance of this algorithm by exploring its implementation details and analyzing its message complexity. Our study of the algorithm’s message complexity has revealed its favorable features. Using the ad\sphinxhyphen{}hoc computing library, we observed a message complexity of O(M + 2E), where M represents the complexity of the fundamental computation. Our experimental results closely match this complexity measure, highlighting the algorithm’s efficiency and low overhead in actual distributed systems. If the algorithm is included in the ad\sphinxhyphen{}hoc computing library, anyone can use it in their research. We discussed how we implemented the underlying computation logic in Section 1.4.3. In future work, we could approach the issue differently and change the implementation to accept any message kind to reflect the variety of algorithms and make the message\sphinxhyphen{}passing mechanism independent from the termination\sphinxhyphen{}detection algorithm.

\sphinxstepscope


\chapter{Assessment Rubric}
\label{\detokenize{docs/rubric:assessment-rubric}}\label{\detokenize{docs/rubric::doc}}
\sphinxAtStartPar
Your work and documentation will be assessed based on the following list of criteria.


\section{Organization and Style}
\label{\detokenize{docs/rubric:organization-and-style}}
\sphinxAtStartPar
{[}15 points{]} The documentation states  title, author names, affiliations and date. The format follows this style?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Structure and Organization: Does the organization of the paper enhance understanding of the material? Is the flow logical with appropriate transitions between sections?

\item {} 
\sphinxAtStartPar
Technical Exposition: Is the technical material presented clearly and logically? Is the material presented at the appropriate level of detail?

\item {} 
\sphinxAtStartPar
Clarity: Is the writing clear, unambiguous and direct? Is there excessive use of jargon, acronyms or undefined terms?

\item {} 
\sphinxAtStartPar
Style: Does the writing adhere to conventional rules of grammar and style? Are the references sufficient and appropriate?

\item {} 
\sphinxAtStartPar
Length: Is the length of the paper appropriate to the technical content?

\item {} 
\sphinxAtStartPar
Illustrations: Do the figures and tables enhance understanding of the text? Are they well explained? Are they of appropriate number, format and size?

\item {} 
\sphinxAtStartPar
Documentation style: Did you follow the expected documentation style (rst or latex)?

\end{enumerate}


\section{Abstract}
\label{\detokenize{docs/rubric:abstract}}
\sphinxAtStartPar
{[}10 points{]} Does the abstract summarize the documentation?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Motivation/problem statement: Why do we care about the problem? What practical, scientific or theoretical gap is your research filling?

\item {} 
\sphinxAtStartPar
Methods/procedure/approach: What did you actually do to get your results?

\item {} 
\sphinxAtStartPar
Results/findings/product: As a result of completing the above procedure, what did you learn/invent/create? What are the main learning points?

\item {} 
\sphinxAtStartPar
Conclusion/implications: What are the larger implications  of your findings, especially for the problem/gap identified?

\end{enumerate}


\section{Introduction and the Problem}
\label{\detokenize{docs/rubric:introduction-and-the-problem}}
\sphinxAtStartPar
{[}15 points{]} The problem section must be specific. The title of the section must indicate your problem. Do not use generic titles.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Is the problem clearly stated?

\item {} 
\sphinxAtStartPar
Is the problem practically important?

\item {} 
\sphinxAtStartPar
What is the purpose of the study?

\item {} 
\sphinxAtStartPar
What is the hypothesis?

\item {} 
\sphinxAtStartPar
Are the key terms defined?

\end{enumerate}


\section{Background and Related Work}
\label{\detokenize{docs/rubric:background-and-related-work}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation present the background and related work in separate sections.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Are the cited sources pertinent to the study?

\item {} 
\sphinxAtStartPar
Is the review too broad or too narrow?

\item {} 
\sphinxAtStartPar
Are the references/citation recent or appropriate?

\item {} 
\sphinxAtStartPar
Is there any evidence of bias?

\end{enumerate}


\section{Implementation and Methodology}
\label{\detokenize{docs/rubric:implementation-and-methodology}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation present the design of the study.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What research methodology was used?

\item {} 
\sphinxAtStartPar
Was it a replica study or an original study?

\item {} 
\sphinxAtStartPar
What measurement tools were used?

\item {} 
\sphinxAtStartPar
How were the procedures structured and the implementation done?

\item {} 
\sphinxAtStartPar
Were extensive exprimentations conducted providing not only means but also confidence intervals?

\item {} 
\sphinxAtStartPar
What are the assessed parameters and were they adequate?

\item {} 
\sphinxAtStartPar
How was sampling and measurement performed?

\end{enumerate}


\section{Analysis and Discussion}
\label{\detokenize{docs/rubric:analysis-and-discussion}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation present the analysis?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Did you collected enough and adequate data for analysis?

\item {} 
\sphinxAtStartPar
How was data analyzed?

\item {} 
\sphinxAtStartPar
Was data qualitative or quantitative?

\item {} 
\sphinxAtStartPar
Did you provide main learning points based on analysis and results?

\item {} 
\sphinxAtStartPar
Did findings support the hypothesis and purpose?

\item {} 
\sphinxAtStartPar
Did you provide discussion as to the main learning points?

\item {} 
\sphinxAtStartPar
Were weaknesses and problems discussed?

\end{enumerate}


\section{Conclusion and Future Work}
\label{\detokenize{docs/rubric:conclusion-and-future-work}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation state the conclusion and future work clearly?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Are the conclusions of the study related to the original purpose?

\item {} 
\sphinxAtStartPar
Were the implications discussed?

\item {} 
\sphinxAtStartPar
Whom will the results and conclusions effect?

\item {} 
\sphinxAtStartPar
What recommendations were made at the conclusion?

\item {} 
\sphinxAtStartPar
Did you provide future work and suggestions?

\end{enumerate}

\sphinxstepscope


\chapter{Code Documentation}
\label{\detokenize{docs/ShavitFrancez/code:code-documentation}}\label{\detokenize{docs/ShavitFrancez/code::doc}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:module-ShavitFrancez.ShavitFrancez}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ShavitFrancez.ShavitFrancez}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\section{ShavitFrancez.ShavitFrancez}
\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:module-ShavitFrancez.ShavitFrancez}}\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:shavitfrancez-shavitfrancez}}\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez::doc}}\index{module@\spxentry{module}!ShavitFrancez.ShavitFrancez@\spxentry{ShavitFrancez.ShavitFrancez}}\index{ShavitFrancez.ShavitFrancez@\spxentry{ShavitFrancez.ShavitFrancez}!module@\spxentry{module}}\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{ShavitFrancezComponentModel (class in ShavitFrancez.ShavitFrancez)@\spxentry{ShavitFrancezComponentModel}\spxextra{class in ShavitFrancez.ShavitFrancez}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{ShavitFrancez.ShavitFrancez.}}\sphinxbfcode{\sphinxupquote{ShavitFrancezComponentModel}}}{\sphinxparam{\DUrole{n}{componentname}}\sphinxparamcomma \sphinxparam{\DUrole{n}{componentinstancenumber}}\sphinxparamcomma \sphinxparam{\DUrole{n}{topology}}\sphinxparamcomma \sphinxparam{\DUrole{n}{context}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{configurationparameters}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{num\_worker\_threads}\DUrole{o}{=}\DUrole{default_value}{1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{child\_conn}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{node\_queues}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{channel\_queues}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures\index{on\_init() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_init()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_init}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_init}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{on\_receiving\_send\_basic\_message() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_receiving\_send\_basic\_message()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_receiving_send_basic_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_send\_basic\_message}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{on\_receiving\_detect\_termination() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_receiving\_detect\_termination()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_receiving_detect_termination}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_detect\_termination}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method makes the proces receiving the DETECTTERMINATION event
active and sets its parent to itself. Then it makes the process send
basic messages to all of its neighbors.

\end{fulllineitems}

\index{on\_receiving\_basic\_message() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_receiving\_basic\_message()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_receiving_basic_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_basic\_message}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method makes the process receiving the basic message active if not already and sets its parent
to the process sending the basic message. If the process was already active, then it sends an
acknowledge message to the process sending the basic message.

\end{fulllineitems}

\index{on\_receiving\_acknowledge\_message() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_receiving\_acknowledge\_message()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_receiving_acknowledge_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_acknowledge\_message}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method decreases the number of children of the process receiving
the acknowledge message by one and calls the leave tree procedure for it.

\end{fulllineitems}

\index{on\_receiving\_become\_passive() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_receiving\_become\_passive()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_receiving_become_passive}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_become\_passive}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The process receiving the BECOMEPASSIVE event transitions to passive
state if not already passive, and calls the leave tree procedure.

\end{fulllineitems}

\index{on\_message\_from\_bottom() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_message\_from\_bottom()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_message_from_bottom}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_message\_from\_bottom}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method calls the related methods according to the message type of
the MFRT event.

\end{fulllineitems}

\index{send\_basic\_message() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{send\_basic\_message()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.send_basic_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{send\_basic\_message}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This method increases the number of children of the process
and makes the process send basic messages to its neighbors

\end{fulllineitems}

\index{send\_wave\_message() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{send\_wave\_message()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.send_wave_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{send\_wave\_message}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This method sends wave messages to the process’ all its neighbors

\end{fulllineitems}

\index{on\_receiving\_start\_wave() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{on\_receiving\_start\_wave()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.on_receiving_start_wave}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_start\_wave}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method implements the Echo algorithm on processes that
are currently not active and do not have any children.

\end{fulllineitems}

\index{generate\_message() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{generate\_message()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.generate_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate\_message}}}{\sphinxparam{\DUrole{n}{messagetype}}\sphinxparamcomma \sphinxparam{\DUrole{n}{messageto}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{leave\_tree() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{leave\_tree()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.leave_tree}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{leave\_tree}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This method checks if the process is not currenty active and does not have any children.
According to that, if also the process has a parent, it sends acknowledge message to its
parent and leaves the parent’s tree. If the process does not have any parent, then it
starts a wave.

\end{fulllineitems}

\index{decide() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{decide()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.decide}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{decide}}}{}{}
\pysigstopsignatures
\end{fulllineitems}

\index{announce() (ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method)@\spxentry{announce()}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezComponentModel.announce}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{announce}}}{}{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{ShavitFrancezEventTypes (class in ShavitFrancez.ShavitFrancez)@\spxentry{ShavitFrancezEventTypes}\spxextra{class in ShavitFrancez.ShavitFrancez}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{ShavitFrancez.ShavitFrancez.}}\sphinxbfcode{\sphinxupquote{ShavitFrancezEventTypes}}}{\sphinxparam{\DUrole{n}{value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names=\textless{}not given\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{*values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{module=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qualname=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{type=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start=1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary=None}}}{}
\pysigstopsignatures\index{DETECTTERMINATION (ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes attribute)@\spxentry{DETECTTERMINATION}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes.DETECTTERMINATION}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{DETECTTERMINATION}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}DETECTTERMINATION\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{BECOMEPASSIVE (ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes attribute)@\spxentry{BECOMEPASSIVE}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes.BECOMEPASSIVE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{BECOMEPASSIVE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}BECOMEPASSIVE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{SENDBASICMESSAGE (ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes attribute)@\spxentry{SENDBASICMESSAGE}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezEventTypes.SENDBASICMESSAGE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{SENDBASICMESSAGE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}SENDBASICMESSAGE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{ShavitFrancezMessageTypes (class in ShavitFrancez.ShavitFrancez)@\spxentry{ShavitFrancezMessageTypes}\spxextra{class in ShavitFrancez.ShavitFrancez}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{ShavitFrancez.ShavitFrancez.}}\sphinxbfcode{\sphinxupquote{ShavitFrancezMessageTypes}}}{\sphinxparam{\DUrole{n}{value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names=\textless{}not given\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{*values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{module=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qualname=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{type=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start=1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary=None}}}{}
\pysigstopsignatures\index{ACKNOWLEDGE (ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute)@\spxentry{ACKNOWLEDGE}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes.ACKNOWLEDGE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{ACKNOWLEDGE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}ACKNOWLEDGE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{BASICMESSAGE (ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute)@\spxentry{BASICMESSAGE}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes.BASICMESSAGE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{BASICMESSAGE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}BASICMESSAGE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{WAVE (ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute)@\spxentry{WAVE}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes.WAVE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{WAVE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}WAVE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{NOTIFYPROCESSES (ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute)@\spxentry{NOTIFYPROCESSES}\spxextra{ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:ShavitFrancez.ShavitFrancez.ShavitFrancezMessageTypes.NOTIFYPROCESSES}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{NOTIFYPROCESSES}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}NOTIFYPROCESSES\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}


\begin{sphinxadmonition}{attention}{Attention:}
\sphinxAtStartPar
For RST details, please refer to \sphinxhref{https://docutils.sourceforge.io/rst.html}{reStructuredText Documentation}.
\end{sphinxadmonition}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{Dijkstra}
\bibitem[ShavitFrancez1986]{docs/ShavitFrancez/algorithm:shavitfrancez1986}
\sphinxAtStartPar
Shavit, N. and Francez, N. A new approach to the detection of locally indicative stability. In proc. Int. Colloq. Automata, Languages, and Programming (1986), L. Kott (ed.), vol. 226 of Lecture Notes in Computer Science, Springer\sphinxhyphen{}Verlag, pp. 344\sphinxhyphen{}358.
\bibitem[Fokking2013]{docs/ShavitFrancez/algorithm:fokking2013}
\sphinxAtStartPar
Wan Fokkink, Distributed Algorithms An Intuitive Approach, The MIT Press Cambridge, Massachusetts London, England, 2013
\bibitem[DijkstraSholten1980]{docs/ShavitFrancez/algorithm:dijkstrasholten1980}
\sphinxAtStartPar
Dijkstra, E. W. and Scholten, C. S. Termination detection for diffusing computations. Inf. Proc. Lett. 11, 1 (1980), 1\sphinxhyphen{}4.
\bibitem[Tel2001]{docs/ShavitFrancez/algorithm:tel2001}
\sphinxAtStartPar
Tel, G, Introduction To Distributed Algorithms, The Cambridge University Press, Cambridge, United Kingdom, 2001
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{s}
\item\relax\sphinxstyleindexentry{ShavitFrancez.ShavitFrancez}\sphinxstyleindexpageref{docs/ShavitFrancez/generated/ShavitFrancez.ShavitFrancez:\detokenize{module-ShavitFrancez.ShavitFrancez}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}