%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Distributed Algorithm on AHCv2: BrachaTauegAlg}
\date{Mar 25, 2024}
\release{V1.0.0}
\author{İmre Kosdik}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\label{\detokenize{docs/BrachaTouegAlg/BrachaTouegAlg:brachatouegalg}}\label{\detokenize{docs/BrachaTouegAlg/BrachaTouegAlg::doc}}
\sphinxstepscope


\section{Abstract}
\label{\detokenize{docs/BrachaTouegAlg/abstract:abstract}}\label{\detokenize{docs/BrachaTouegAlg/abstract::doc}}
\sphinxAtStartPar
In distributed systems, deadlocks occur due to resource sharing \sphinxhyphen{} the concept determines how existing resources are shared and accessed across the system. A deadlock is a condition that the processes request access to resources held by other processes in the system. Resolving the deadlocks is crucial because the processes involved are blocked and waiting indefinitely to acquire resources from the others. Deadlock handling is a challenging problem in distributed systems because no site knows the system state, and the communication involves finite and unpredictable delays. Deadlock detection is one of the approaches to handling deadlocks. It consists of examining the system for a cyclic wait. The Bracha\sphinxhyphen{}Toueg algorithm is a simple and efficient deadlock detection algorithm and is under global state detection\sphinxhyphen{}based algorithms. The main idea behind the algorithm is that deadlocks are detectable by taking a snapshot of the system. Moreover, the algorithm’s complexity outperforms the previously introduced deadlock detection algorithms. // TBD: what is my contribution and summarization of the learning points referring to the results.

\sphinxstepscope


\section{Introduction}
\label{\detokenize{docs/BrachaTouegAlg/introduction:introduction}}\label{\detokenize{docs/BrachaTouegAlg/introduction::doc}}
\sphinxAtStartPar
Distributed systems are desirable because they allow resource sharing, a critical concept that determines how existing resources are shared and accessed across the network. However, resource sharing comes at a price \sphinxhyphen{} namely, deadlocks. A deadlock is a condition that the processes request access to resources held by other processes in the system. Deadlocks can cause significant delays and affect the system’s performance, making it crucial to resolve them as soon as possible.

\sphinxAtStartPar
Deadlock detection algorithms are crucial and intriguing due to their role in concurrency and control mechanisms in distributed systems. Since they help identify and resolve the deadlocks, they prevent system failures and waste of resources. Moreover, they improve the system’s reliability by resolving the deadlocks. The absence of deadlock detection algorithms causes execution halts since deadlocks state that the processes cannot continue their work. Also, it wastes resources because resources held by the processes are neither used nor released. Therefore, this can affect the system’s scalability, response time, and throughput. Overall, deadlocks are inherent risks in concurrent and distributed computing environments, and effective detection mechanisms are essential for mitigating their impact and ensuring the smooth operation of distributed applications.

\sphinxAtStartPar
Deadlock detection is a challenging problem due to various reasons. Because deadlock detection requires storing the system state as a graph, the lack of shared memory becomes a bottleneck for constructing and maintaining the graphs. Another issue is to ensure that each process needs to have an accurate knowledge of the system state. However, in distributed systems, communication delays and failures are almost inevitable. Since distributed systems are large and complex, designing an efficient and scalable deadlock detection algorithm is also challenging. To conclude, naive approaches fail due to scalability, lack of global knowledge, and communication delays.

\sphinxAtStartPar
Several deadlock detection algorithms for distributed systems were proposed other than the Bracha\sphinxhyphen{}Toueg algorithm. Some of those algorithms were proven incorrect, and proof of the others was too complex. The complexity of these algorithms comes from the nature of the distributed systems. What makes the Bracha\sphinxhyphen{}Taueg special is that its time and space complexity is lower than the best previously known deadlock detection algorithm. It also overcomes the challenges of the dynamic system environment by taking a snapshot of the system and then running the algorithm on that snapshot. This approach does not affect the system throughput since the cycle detection process can proceed concurrently with other system activities.

\sphinxAtStartPar
The Bracha\sphinxhyphen{}Toueg algorithm is a global state\sphinxhyphen{}based deadlock detection algorithm, assuming that a consistent global state is determinable without suspending or halting the system. One notable aspect of this algorithm is its ability to provide each process with knowledge of whether or not it is in a deadlocked state, as it always terminates.

\sphinxAtStartPar
Our primary contributions consist of the following: // TBD

\sphinxstepscope


\section{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\label{\detokenize{docs/BrachaTouegAlg/algorithm:brachatouegalg}}\label{\detokenize{docs/BrachaTouegAlg/algorithm::doc}}

\subsection{Background and Related Work}
\label{\detokenize{docs/BrachaTouegAlg/algorithm:background-and-related-work}}
\sphinxAtStartPar
A deadlock occurs when a group of processes waits for each other to acquire resources to continue their execution. One of the deadlock models is N\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}M Requests, where N is less than or equal to M. In this model, a process makes M requests and can continue execution only if it obtains at least N resources.

\sphinxAtStartPar
Wait\sphinxhyphen{}for\sphinxhyphen{}graphs model the resource dependencies in distributed systems.{[}Kshemkalyani2008{]}\_ In these graphs, nodes represent processes, and there is a directed edge from one process to another if the first process is waiting to acquire a resource that the second process is currently holding. A process can be either active or blocked. An active process has all the resources it needs and is either executing or ready to execute. On the other hand, a blocked process is waiting to acquire the resources it needs.

\sphinxAtStartPar
An active node in a WFG can send an N\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}M request. After sending the request, the node becomes blocked until at least N of the requests are granted. Once the node becomes blocked, it cannot send any more requests. Directed edges are included in the graph to indicate the requests, and they go from the node to each node containing the required resources. As nodes grant the resources to the blocked node, the system removes the directed edges correspondingly. Once N requests are approved, the node becomes active again and sends notifications to M\sphinxhyphen{}N nodes to dismiss the remaining requests. After that, the system removes the remaining directed edges accordingly.{[}Bracha1987{]}\_{[}Fokking2013{]}\_

\sphinxAtStartPar
Deadlock detection is a fundamental problem in distributed computing, which requires examining the system’s WFG for cyclic dependencies. For this purpose, the processes in the system periodically check whether the system contains any deadlock by taking a snapshot of the global state of the system. According to Knapp’s deadlock detection algorithm classification, this approach falls under the global state\sphinxhyphen{}based algorithms. The Bracha\sphinxhyphen{}Toueg deadlock detection algorithm is also one of them. Next, we will discuss the implementation details, the correctness, and the complexity analysis of the Bracha\sphinxhyphen{}Toueg algorithm.


\subsection{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm: Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\label{\detokenize{docs/BrachaTouegAlg/algorithm:bracha-toueg-deadlock-detection-algorithm-brachatouegalg}}
\sphinxAtStartPar
The Bracha\sphinxhyphen{}Toueg Deadlock Detection:ref:{\color{red}\bfseries{}\textasciigrave{}}Algorithm \textless{}BrachaTouegDeadlockDetectionAlgorithm\textgreater{}\textasciigrave{}{[}Bracha1987{]}\_, proposed by Gabriel Bracha and Sam Toueg, aims to detect the deadlocks in the system. The algorithm operates on the N\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}M deadlock model and is under the assumption that it is possible to capture the consistent global state of the system without halting the system execution. The algorithm starts execution when a node, named initiator, suspects that it may be in a deadlocked state. This can happen after a long wait for a request to be satisfied. The initiator starts a Lai\sphinxhyphen{}Yang snapshot to compute the WFG. To differentiate between snapshots invoked by different initiators, the algorithm associates each snapshot, along with its messages, with the initiator’s identity. After a node v constructs its snapshot, it computes two sets of nodes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{OUTv}: The set of nodes \sphinxstyleemphasis{u} for which \sphinxstyleemphasis{v}’s request has not been granted or relinquished.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{INv}: The set of nodes requesting a service from \sphinxstyleemphasis{v}, according to \sphinxstyleemphasis{v}’s point of view. The node \sphinxstyleemphasis{v} received requests from a set of nodes, but \sphinxstyleemphasis{v} has not yet granted or dismissed the requests.

\end{enumerate}

\sphinxAtStartPar
After computing each set of nodes, the algorithm consists of two phases. \sphinxstyleemphasis{Notify} \sphinxhyphen{} where processes are notified that the algorithm started execution \sphinxhyphen{} and \sphinxstyleemphasis{Grant} in which active processes simulate the granting of requests. The \sphinxstyleemphasis{initiator} node starts by sending a notify message to all its outgoing edges and then executes \sphinxstyleemphasis{Grant}. Other non\sphinxhyphen{}initiator nodes that receive the notify message from the initiator execute \sphinxstyleemphasis{Notify}. Once the nodes become unblocked, they also grant the pending requests by executing \sphinxstyleemphasis{Grant}. The \sphinxstyleemphasis{Grant} phase is nested inside the \sphinxstyleemphasis{Notify} phase. Therefore, \sphinxstyleemphasis{Notify} terminates only after \sphinxstyleemphasis{Grant} terminates. It terminates when \sphinxstyleemphasis{Notify} terminates. At termination, the \sphinxstyleemphasis{initiator} is not deadlocked if and only if its \sphinxstyleemphasis{free} value is true.
\sphinxSetupCaptionForVerbatim{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm \sphinxcite{docs/BrachaTouegAlg/algorithm:fokking2013}.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{docs/BrachaTouegAlg/algorithm:id14}}\label{\detokenize{docs/BrachaTouegAlg/algorithm:brachatouegdeadlockdetectionalgorithm}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Procedure Notify
notified \PYGZlt{}\PYGZhy{} true
send\PYGZlt{}notify\PYGZgt{} to all w ∈  OUT
if requests = 0 then
            perform Procedure Grant
    end if
await\PYGZlt{}done\PYGZgt{} from all w ∈ OUT

Upon receipt by v of Notify from a neighbor w:
If notified = false then
            Perform Procedure Notify
end if
send\PYGZlt{}done\PYGZgt{} to w

Procedure Grant
free \PYGZlt{}\PYGZhy{} true
send\PYGZlt{}grant\PYGZgt{} to all w ∈ IN
await\PYGZlt{}ack\PYGZgt{} from all w ∈ IN

Upon receipt by v of Grant from a neighbor w:
If requests \PYGZgt{} 0 then
            requests \PYGZlt{}\PYGZhy{} requestv \PYGZhy{} 1
    if requests = 0 then
                    Perform procedure Grant
            end if
end if
send\PYGZlt{}ack\PYGZgt{} to w
\end{sphinxVerbatim}


\subsection{Example}
\label{\detokenize{docs/BrachaTouegAlg/algorithm:example}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics{{bracha_example_step1}.jpg}
\sphinxfigcaption{Fig 1. Step 1}\label{\detokenize{docs/BrachaTouegAlg/algorithm:id15}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics{{bracha_example_step2}.jpeg}
\sphinxfigcaption{Fig 2. Step 2}\label{\detokenize{docs/BrachaTouegAlg/algorithm:id16}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Assume a system with three processes, A, B and C. The wait\sphinxhyphen{}for graph consists of three 1\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}1 requests, has been computed in a snapshot. Initially \sphinxstyleemphasis{requests\textless{}A\textgreater{}} = \sphinxstyleemphasis{requests\textless{}B\textgreater{}} = \sphinxstyleemphasis{requests\textless{}C\textgreater{}} = 1
The walkthrough of Bracha\sphinxhyphen{}Toueg:ref:{\color{red}\bfseries{}\textasciigrave{}}Algorithm \textless{}BrachaTouegDeadlockDetectionAlgorithm\textgreater{}\textasciigrave{}{[}Bracha1987{]}\_ is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The initiator A, sets \sphinxstyleemphasis{notified\textless{}A\textgreater{}} to true and sends \textless{}\sphinxstylestrong{notify}\textgreater{} to B. A awaits \textless{}\sphinxstylestrong{done}\textgreater{} from B. (See Figure 1)

\item {} 
\sphinxAtStartPar
B receives \textless{}\sphinxstylestrong{notify}\textgreater{} from A and sets \sphinxstyleemphasis{notified\textless{}B\textgreater{}} to true. In order to send \textless{}\sphinxstylestrong{done}\textgreater{} to A, B sends \textless{}\sphinxstylestrong{nofity}\textgreater{} to C and awaits \textless{}\sphinxstylestrong{done}\textgreater{} from C. (See Figure 1)

\item {} 
\sphinxAtStartPar
C receives \textless{}\sphinxstylestrong{notify}\textgreater{} from B and sets \sphinxstyleemphasis{notified\textless{}C\textgreater{}} to true. In order to send \textless{}\sphinxstylestrong{done}\textgreater{} to B, C sends \textless{}\sphinxstylestrong{nofity}\textgreater{} to A and awaits \textless{}\sphinxstylestrong{done}\textgreater{} from A. (See Figure 1)

\item {} 
\sphinxAtStartPar
Since \sphinxstyleemphasis{notified\textless{}A\textgreater{}} is true, A does not send any \textless{}\sphinxstylestrong{notify}\textgreater{} messages. It directly sends \textless{}\sphinxstylestrong{done}\textgreater{} to C. (See Figure 2)

\item {} 
\sphinxAtStartPar
C sends \textless{}\sphinxstylestrong{done}\textgreater{} to B because C is already notified. (See Figure 2)

\item {} 
\sphinxAtStartPar
B sends \textless{}\sphinxstylestrong{done}\textgreater{} to A because B is already notified. (See Figure 2)

\item {} 
\sphinxAtStartPar
Once A receives \textless{}\sphinxstylestrong{done}\textgreater{} from all its OUT, consisting of B, it checks the \sphinxstyleemphasis{free\textless{}A\textgreater{}}, and since \sphinxstyleemphasis{free\textless{}A\textgreater{}} is false, it concludes that the resources are never granted and it is deadlocked.

\end{enumerate}


\subsection{Correctness}
\label{\detokenize{docs/BrachaTouegAlg/algorithm:correctness}}

\subsection{Complexity}
\label{\detokenize{docs/BrachaTouegAlg/algorithm:complexity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Time Complexity:} The Bracha\sphinxhyphen{}Toueg:ref:{\color{red}\bfseries{}\textasciigrave{}}Algorithm \textless{}BrachaTouegDeadlockDetectionAlgorithm\textgreater{}\textasciigrave{}{[}Bracha1987{]}\_  has time complexity of 4 * d hops, where d is the diameter of a given WFG.{[}Kshemkalyani1994{]}\_

\item {} 
\sphinxAtStartPar
{\color{red}\bfseries{}**}Message Complexity:{\color{red}\bfseries{}**}The Bracha\sphinxhyphen{}Toueg:ref:{\color{red}\bfseries{}\textasciigrave{}}Algorithm \textless{}BrachaTouegDeadlockDetectionAlgorithm\textgreater{}\textasciigrave{}{[}Bracha1987{]}\_  has message complexity of 4 * e messages, where e is the number of the edges in a given WFG.{[}Kshemkalyani1994{]}\_

\end{enumerate}

\sphinxstepscope


\section{Implementation, Results and Discussion}
\label{\detokenize{docs/BrachaTouegAlg/results:implementation-results-and-discussion}}\label{\detokenize{docs/BrachaTouegAlg/results::doc}}

\subsection{Implementation and Methodology}
\label{\detokenize{docs/BrachaTouegAlg/results:implementation-and-methodology}}

\subsection{Results}
\label{\detokenize{docs/BrachaTouegAlg/results:results}}

\subsection{Discussion}
\label{\detokenize{docs/BrachaTouegAlg/results:discussion}}
\sphinxstepscope


\section{Conclusion}
\label{\detokenize{docs/BrachaTouegAlg/conclusion:conclusion}}\label{\detokenize{docs/BrachaTouegAlg/conclusion::doc}}
\sphinxstepscope


\chapter{Code Documentation}
\label{\detokenize{docs/BrachaTouegAlg/code:code-documentation}}\label{\detokenize{docs/BrachaTouegAlg/code::doc}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{attention}{Attention:}
\sphinxAtStartPar
For RST details, please refer to \sphinxhref{https://docutils.sourceforge.io/rst.html}{reStructuredText Documentation}.
\end{sphinxadmonition}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{Kshemkal}
\bibitem[Fokking2013]{docs/BrachaTouegAlg/algorithm:fokking2013}
\sphinxAtStartPar
Wan Fokkink, Distributed Algorithms An Intuitive Approach, The MIT Press Cambridge, Massachusetts London, England, 2013
\bibitem[Bracha1987]{docs/BrachaTouegAlg/algorithm:bracha1987}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
\sphinxAtStartPar
Bracha and S. Toeug, “Distributed Deadlock detection”. Distributed Comput., vol. 2, pp. 127\sphinxhyphen{}138, 1987.

\end{enumerate}
\bibitem[Kshemkalyani2008]{docs/BrachaTouegAlg/algorithm:kshemkalyani2008}
\sphinxAtStartPar
Ajay D. Kshemkalyani, Mukesh Singhal, Distributed Computing: Principles, Algorithms and Systems, Cambridge Univeristy Press, New York, USA, 2008
\bibitem[Kshemkalyani1994]{docs/BrachaTouegAlg/algorithm:kshemkalyani1994}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\item {} \begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumii}{enumiii}{}{.}%
\setcounter{enumii}{3}
\item {} 
\sphinxAtStartPar
Kshemkalyani and M. Singhal, “Efficient detection and resolution of generalized distributed deadlocks,” in IEEE Transactions on Software Engineering, vol. 20, no. 1, pp. 43\sphinxhyphen{}54, Jan. 1994,

\end{enumerate}

\end{enumerate}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}