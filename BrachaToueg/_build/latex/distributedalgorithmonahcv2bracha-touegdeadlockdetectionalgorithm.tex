%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}

\usepackage{nbsphinx}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Contents}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Distributed Algorithm on AHCv2: Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\date{May 11, 2024}
\release{V1.0.0}
\author{İmre Kosdik}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\label{\detokenize{docs/BrachaToueg/BrachaToueg:brachatouegalg}}\label{\detokenize{docs/BrachaToueg/BrachaToueg::doc}}
\sphinxstepscope


\section{Abstract}
\label{\detokenize{docs/BrachaToueg/abstract:abstract}}\label{\detokenize{docs/BrachaToueg/abstract::doc}}
\sphinxAtStartPar
In distributed systems, deadlocks occur due to resource sharing \sphinxhyphen{} the concept determines how existing resources are shared and accessed across the system. A deadlock is a condition that the processes request access to resources held by other processes in the system. Resolving the deadlocks is crucial because the processes involved are blocked and waiting indefinitely to acquire resources from the others. Deadlock handling is a challenging problem in distributed systems because no site knows the system state, and the communication involves finite and unpredictable delays. {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}} offers a simple and efficient way of detecting deadlocks in distributed systems. Implementing {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}}, along with analyzing the message and time complexity by running the algorithm on different network topologies and various numbers of nodes, provides valuable insights into the algorithm’s wide\sphinxhyphen{}range applicability due to its efficiency and scalability.

\sphinxstepscope


\section{Introduction}
\label{\detokenize{docs/BrachaToueg/introduction:introduction}}\label{\detokenize{docs/BrachaToueg/introduction::doc}}
\sphinxAtStartPar
Distributed systems are desirable because they allow resource sharing, a critical concept determining how existing resources are shared and accessed across the network. However, resource sharing comes at a price \sphinxhyphen{} namely, deadlocks. A deadlock is a condition that the processes request access to resources held by other processes in the system. Deadlocks can cause significant delays and affect a distributed system’s performance, making it crucial to resolve them as soon as possible.

\sphinxAtStartPar
Deadlock detection algorithms are crucial due to their role in concurrency and control mechanisms in distributed systems. Since they help identify and resolve the deadlocks, they prevent system failures and waste of resources. Moreover, they improve systems’ reliability by contributing to deadlock resolution. The absence of deadlock detection algorithms causes execution halts since deadlocks state that the processes cannot continue their work. Also, it wastes resources because resources held by the processes are neither used nor released. Therefore, this can affect a system’s scalability, response time, and throughput. Overall, deadlocks are inherent risks in concurrent and distributed computing environments, and effective detection mechanisms are essential for mitigating their impact and ensuring the smooth operation of distributed applications.

\sphinxAtStartPar
Because deadlock detection requires storing the system state as a graph, the lack of shared memory becomes a bottleneck for constructing and maintaining the graphs. Another issue is to ensure that each process needs to have an accurate knowledge of the system state. However, in distributed systems, communication delays and failures are almost inevitable. Since distributed systems are large and complex, designing an efficient and scalable deadlock detection algorithm is also challenging.

\sphinxAtStartPar
In this paper, we aim to thoroughly explain the implementation details of {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}}, discuss how the algorithm overcomes the challenges arising from the nature of distributed systems, and present the results of experiments we conducted on the algorithm related to its time and message complexity. The experiments prove the algorithm is a valuable asset in detecting deadlocks due to its efficiency and simplicity.

\sphinxAtStartPar
We contribute to the field of distributed systems by:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Implementating {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}} on the AHCv2 platform. We explain the implementation details in Section 1.3.

\item {} 
\sphinxAtStartPar
Conducting experiments on the algorithm over different network topologies and node counts. We discuss the experiment setup and results in Section 1.4

\end{itemize}

\sphinxstepscope


\section{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\label{\detokenize{docs/BrachaToueg/algorithm:brachatouegalg}}\label{\detokenize{docs/BrachaToueg/algorithm::doc}}

\subsection{Background and Related Work}
\label{\detokenize{docs/BrachaToueg/algorithm:background-and-related-work}}
\sphinxAtStartPar
A deadlock occurs when a group of processes waits for each other to acquire resources to continue their execution. One of the deadlock models is N\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}M Requests, where N is less than or equal to M. In this model, a process makes M requests and can continue execution only if it obtains at least N resources.

\sphinxAtStartPar
Wait\sphinxhyphen{}for\sphinxhyphen{}graphs model the resource dependencies in distributed systems. \sphinxcite{docs/BrachaToueg/algorithm:kshemkalyani2008} In these graphs, nodes represent processes, and there is a directed edge from one process to another if the first process is waiting to acquire a resource that the second process is currently holding. A process can be either active or blocked. An active process has all the resources it needs and is either executing or ready to execute. On the other hand, a blocked process is waiting to acquire the resources it needs.

\sphinxAtStartPar
An active node in a WFG can send an N\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}M request. After sending the request, the node becomes blocked until at least N of the requests are granted. Once the node becomes blocked, it cannot send any more requests. Directed edges are included in the graph to indicate the requests, and they go from the node to each node containing the required resources. As nodes grant the resources to the blocked node, the system removes the directed edges correspondingly. Once N requests are approved, the node becomes active again and sends notifications to M\sphinxhyphen{}N nodes to dismiss the remaining requests. After that, the system removes the remaining directed edges accordingly. \sphinxcite{docs/BrachaToueg/algorithm:bracha1987} \sphinxcite{docs/BrachaToueg/algorithm:fokking2013}

\sphinxAtStartPar
Deadlock detection is a fundamental problem in distributed computing, which requires examining the system’s WFG for cyclic dependencies. For this purpose, the processes in the system periodically check whether the system contains any deadlock by taking a snapshot of the global state of the system.  According to Knapp’s deadlock detection algorithm classification \sphinxcite{docs/BrachaToueg/algorithm:knapp1987}, this approach falls under the global state\sphinxhyphen{}based algorithms. These algorithms including the {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}} is based on Lai\sphinxhyphen{}Yang Snapshot Algorithm \sphinxcite{docs/BrachaToueg/algorithm:fokking2013} because the algorithm computes WFG depending on the global snapshot of the system.


\subsection{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm: Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}
\label{\detokenize{docs/BrachaToueg/algorithm:bracha-toueg-deadlock-detection-algorithm-brachatouegalg}}
\sphinxAtStartPar
The {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}}, proposed by Gabriel Bracha and Sam Toueg \sphinxcite{docs/BrachaToueg/algorithm:bracha1987}, aims to detect the deadlocks in the system. The algorithm operates on the N\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}M deadlock model and is under the assumption that it is possible to capture the consistent global state of the system without halting the system execution. The algorithm starts execution when a node, named initiator, suspects that it may be in a deadlocked state. This can happen after a long wait for a request to be satisfied. The initiator starts a Lai\sphinxhyphen{}Yang snapshot {\hyperref[\detokenize{docs/BrachaToueg/algorithm:laiyangsnapshotalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Lai\sphinxhyphen{}Yang Snapshot Algorithm}}}} to compute the WFG. To differentiate between snapshots invoked by different initiators, the algorithm associates each snapshot, along with its messages, with the initiator’s identity. After a node v constructs its snapshot, it computes two sets of nodes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{OUTv}: The set of nodes \sphinxstyleemphasis{u} for which \sphinxstyleemphasis{v}’s request has not been granted or relinquished.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{INv}: The set of nodes requesting a service from \sphinxstyleemphasis{v}, according to \sphinxstyleemphasis{v}’s point of view. The node \sphinxstyleemphasis{v} received requests from a set of nodes, but \sphinxstyleemphasis{v} has not yet granted or dismissed the requests.

\end{itemize}

\sphinxAtStartPar
After computing each set of nodes, the algorithm consists of two phases. \sphinxstyleemphasis{Notify} \sphinxhyphen{} where processes are notified that the algorithm started execution \sphinxhyphen{} and \sphinxstyleemphasis{Grant} in which active processes simulate the granting of requests.
\begin{itemize}
\item {} 
\sphinxAtStartPar
The process initiating the deadlock detection algorithm sends NOTIFY messages to all processes in \sphinxstyleemphasis{Outv}. (Line 2)

\item {} 
\sphinxAtStartPar
If the initiator process does not need any resources, it grants its resources to processes needing them by sending \sphinxstyleemphasis{GRANT} messages (Line 19) and makes itself free. (Line 18) It then waits for \sphinxstyleemphasis{ACKNOWLEDGE} messages from these processes indicating that they received the \sphinxstyleemphasis{GRANT} message.(Line 20)

\item {} 
\sphinxAtStartPar
After performing the \sphinxstyleemphasis{GRANT} operation, it waits \sphinxstyleemphasis{DONE} messages from the processes it sent \sphinxstyleemphasis{NOTIFY} message to. (Line 7)

\item {} 
\sphinxAtStartPar
If a process receives \sphinxstyleemphasis{NOTIFY} from another for the first time, it sends NOTIFY messages to all processes in its \sphinxstyleemphasis{Outv}. (Line 14). Then, it sends \sphinxstyleemphasis{DONE} message to the process sending the \sphinxstyleemphasis{NOTIFY} message. (Line 16)

\item {} 
\sphinxAtStartPar
If a process receives \sphinxstyleemphasis{GRANT} message from another, it checks whether it needs additional resources to continue execution. (Line 22). Once it does not need any resources, it grants its resources to waiting processes by executing grant. (Line 25) After that, it sends \sphinxstyleemphasis{ACKNOWLEDGE} message to the process sending the \sphinxstyleemphasis{GRANT} message. (Line 28)

\item {} 
\sphinxAtStartPar
Once the initiator process receives done from all processes in \sphinxstyleemphasis{Outv},(Line 7) it checks the value of \sphinxstyleemphasis{free} and decides whether it is deadlocked. (Line 9)

\end{itemize}
\sphinxSetupCaptionForVerbatim{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm \sphinxcite{docs/BrachaToueg/algorithm:fokking2013}.}
\def\sphinxLiteralBlockLabel{\label{\detokenize{docs/BrachaToueg/algorithm:id12}}\label{\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
Procedure Notify
notified \PYGZlt{}\PYGZhy{} true
send\PYGZlt{}notify\PYGZgt{} to all w ∈  OUT
if requests = 0 then
        perform Procedure Grant
    end if
await\PYGZlt{}done\PYGZgt{} from all w ∈ OUT
if free then:
    conclude that it is not deadlocked
end if

Upon receipt by v of Notify from a neighbor w:
if notified = false then
        Perform Procedure Notify
end if
send\PYGZlt{}done\PYGZgt{} to w

Procedure Grant
free \PYGZlt{}\PYGZhy{} true
send\PYGZlt{}grant\PYGZgt{} to all w ∈ IN
await\PYGZlt{}ack\PYGZgt{} from all w ∈ IN

Upon receipt by v of Grant from a neighbor w:
if requests \PYGZgt{} 0 then
        requests \PYGZlt{}\PYGZhy{} request \PYGZhy{} 1
    if requests = 0 then
            Perform procedure Grant
        end if
end if
send\PYGZlt{}ack\PYGZgt{} to w
\end{sphinxVerbatim}


\subsection{Lai\sphinxhyphen{}Yang Snapshot Algorithm:}
\label{\detokenize{docs/BrachaToueg/algorithm:lai-yang-snapshot-algorithm}}
\sphinxAtStartPar
The {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}}, utilizes {\hyperref[\detokenize{docs/BrachaToueg/algorithm:laiyangsnapshotalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Lai\sphinxhyphen{}Yang Snapshot Algorithm}}}} to compute the WFG graph. Therefore, the process starting the deadlock detection algorithm first executes the Lai\sphinxhyphen{}Yang snapshot algorithm. The deadlock detection algorithm uses the global state information captured with {\hyperref[\detokenize{docs/BrachaToueg/algorithm:laiyangsnapshotalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Lai\sphinxhyphen{}Yang Snapshot Algorithm}}}} to detect deadlocks. Since this paper focuses on implementing the {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}}, we do no explicitly explain the pseudocode given for {\hyperref[\detokenize{docs/BrachaToueg/algorithm:laiyangsnapshotalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Lai\sphinxhyphen{}Yang Snapshot Algorithm}}}} below. We give the pseudocode here since we implemented the algorithm as a part of  {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}}.
\sphinxSetupCaptionForVerbatim{Lai\sphinxhyphen{}Yang Snapshot Algorithm \sphinxcite{docs/BrachaToueg/algorithm:fokking2013}}
\def\sphinxLiteralBlockLabel{\label{\detokenize{docs/BrachaToueg/algorithm:id13}}\label{\detokenize{docs/BrachaToueg/algorithm:laiyangsnapshotalgorithm}}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
bool recorded
nat counter[c] for all channels c of p
mess\PYGZhy{}set State[c] for all incoming channels of p

if p wants to initiate a snapshot
perform Procedure TakeSnapshot

if p sends a basic message m into an outgoing channel c\PYGZlt{}0\PYGZgt{}
send\PYGZlt{}m,recorded\PYGZgt{} into c\PYGZlt{}0\PYGZgt{}
if recorded is False then
    counter[c\PYGZlt{}0\PYGZgt{}] \PYGZlt{}\PYGZhy{} counter[c\PYGZlt{}0\PYGZgt{}] + 1
end if

if p receives \PYGZlt{}m, b\PYGZgt{} through an incomming channel c\PYGZlt{}0\PYGZgt{}
if b = True then
    perform Procedure TakeSnapshot
else
    counter[c\PYGZlt{}0\PYGZgt{}] \PYGZlt{}\PYGZhy{} counter[c\PYGZlt{}0\PYGZgt{}] \PYGZhy{} 1
    if recorded = True then
        State[c\PYGZlt{}0\PYGZgt{}] \PYGZlt{}\PYGZhy{} State[c\PYGZlt{}0\PYGZgt{}] U \PYGZob{}m\PYGZcb{}
        if |State[c]| + 1 = counter[c\PYGZlt{}0\PYGZgt{}] for all incoming channels c of p then
            terminate
        end if
    end if
efficiencynd if


if p receives \PYGZlt{}presnap, l\PYGZgt{} through an incoming channel c\PYGZlt{}0\PYGZgt{}
counter[c\PYGZlt{}0\PYGZgt{}] \PYGZlt{}\PYGZhy{} counter[c\PYGZlt{}0\PYGZgt{}] + L
if |State[c]| + 1 = counter[c\PYGZlt{}0\PYGZgt{}] for all incoming channels c of p then
    terminate
end if

Procedure TakeSnapshot
if recorded = false then
    recorded \PYGZlt{}\PYGZhy{} True
    send \PYGZlt{}presnap, counter\PYGZlt{}c0\PYGZgt{}\PYGZgt{} into each outgoing channel c
    take a local snapshot state of p
end if
\end{sphinxVerbatim}


\subsection{Example With Deadlock Present in The System}
\label{\detokenize{docs/BrachaToueg/algorithm:example-with-deadlock-present-in-the-system}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=1264\sphinxpxdimen,height=520\sphinxpxdimen]{{brachaToueg_Ex1_step1}.png}
\sphinxfigcaption{Step 1}\label{\detokenize{docs/BrachaToueg/algorithm:id14}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=1264\sphinxpxdimen,height=520\sphinxpxdimen]{{brachaToueg_Ex1_step2}.png}
\sphinxfigcaption{Step 2}\label{\detokenize{docs/BrachaToueg/algorithm:id15}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Assume a system with three processes, P, Q and R. The wait\sphinxhyphen{}for graph consists of three 1\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}1 requests, has been computed in a snapshot. Initially \sphinxstyleemphasis{requests\textless{}P\textgreater{}} = \sphinxstyleemphasis{requests\textless{}Q\textgreater{}} = \sphinxstyleemphasis{requests\textless{}R\textgreater{}} = 1.
The walkthrough of the {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}} is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The initiator P, sets \sphinxstyleemphasis{notified\textless{}A\textgreater{}} to true and sends \textless{}\sphinxstylestrong{notify}\textgreater{} to Q. P awaits \textless{}\sphinxstylestrong{done}\textgreater{} from Q. (See Figure 1)

\item {} 
\sphinxAtStartPar
Q receives \textless{}\sphinxstylestrong{notify}\textgreater{} from P and sets \sphinxstyleemphasis{notified\textless{}Q\textgreater{}} to true. In order to send \textless{}\sphinxstylestrong{done}\textgreater{} to P, Q sends \textless{}\sphinxstylestrong{nofity}\textgreater{} to R and awaits \textless{}\sphinxstylestrong{done}\textgreater{} from R. (See Figure 1)

\item {} 
\sphinxAtStartPar
R receives \textless{}\sphinxstylestrong{notify}\textgreater{} from Q and sets \sphinxstyleemphasis{notified\textless{}R\textgreater{}} to true. In order to send \textless{}\sphinxstylestrong{done}\textgreater{} to Q, R sends \textless{}\sphinxstylestrong{nofity}\textgreater{} to P and awaits \textless{}\sphinxstylestrong{done}\textgreater{} from P. (See Figure 1)

\item {} 
\sphinxAtStartPar
Since \sphinxstyleemphasis{notified\textless{}P\textgreater{}} is true, P does not send any \textless{}\sphinxstylestrong{notify}\textgreater{} messages. It directly sends \textless{}\sphinxstylestrong{done}\textgreater{} to R. (See Figure 2)

\item {} 
\sphinxAtStartPar
R sends \textless{}\sphinxstylestrong{done}\textgreater{} to Q because R is already notified. (See Figure 2)

\item {} 
\sphinxAtStartPar
Q sends \textless{}\sphinxstylestrong{done}\textgreater{} to P because Q is already notified. (See Figure 2)

\item {} 
\sphinxAtStartPar
Once P receives \textless{}\sphinxstylestrong{done}\textgreater{} from all its OUT, consisting of Q, it checks the \sphinxstyleemphasis{free\textless{}A\textgreater{}}, and since \sphinxstyleemphasis{free\textless{}P\textgreater{}} is false, it concludes that the resources are never granted and it is deadlocked.

\end{enumerate}


\subsection{Example With Deadlock Not Present in The System}
\label{\detokenize{docs/BrachaToueg/algorithm:example-with-deadlock-not-present-in-the-system}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=829\sphinxpxdimen,height=346\sphinxpxdimen]{{brachaToueg_Ex2_step1}.png}
\sphinxfigcaption{Step 1}\label{\detokenize{docs/BrachaToueg/algorithm:id16}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=829\sphinxpxdimen,height=346\sphinxpxdimen]{{brachaToueg_Ex2_step2}.png}
\sphinxfigcaption{Step 2}\label{\detokenize{docs/BrachaToueg/algorithm:id17}}\end{sphinxfigure-in-table}\relax
\\
\sphinxhline\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=829\sphinxpxdimen,height=346\sphinxpxdimen]{{brachaToueg_Ex2_step3}.png}
\sphinxfigcaption{Step 3}\label{\detokenize{docs/BrachaToueg/algorithm:id18}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=829\sphinxpxdimen,height=346\sphinxpxdimen]{{brachaToueg_Ex2_step4}.png}
\sphinxfigcaption{Step 4}\label{\detokenize{docs/BrachaToueg/algorithm:id19}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Assume a system with three processes, P, Q and R. The wait\sphinxhyphen{}for graph consists of three 1\sphinxhyphen{}out\sphinxhyphen{}of\sphinxhyphen{}1 requests, has been computed in a snapshot. Initially \sphinxstyleemphasis{requests\textless{}P\textgreater{}} = 2, \sphinxstyleemphasis{requests\textless{}Q\textgreater{}} = 1 and \sphinxstyleemphasis{requests\textless{}R\textgreater{}} = 0.
The walkthrough of the {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm}}}} is as follows:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
The initiator P, sets \sphinxstyleemphasis{notified\textless{}P\textgreater{}} to true and sends \textless{}\sphinxstylestrong{notify}\textgreater{} to Q and R. A awaits \textless{}\sphinxstylestrong{done}\textgreater{} from Q and R. (See Figure 3)

\item {} 
\sphinxAtStartPar
Q receives \textless{}\sphinxstylestrong{notify}\textgreater{} from P and sets \sphinxstyleemphasis{notified\textless{}Q\textgreater{}} to true. In order to send \textless{}\sphinxstylestrong{done}\textgreater{} to P, Q sends \textless{}\sphinxstylestrong{nofity}\textgreater{} to R and awaits \textless{}\sphinxstylestrong{done}\textgreater{} from R. (See Figure 3)

\item {} 
\sphinxAtStartPar
R receives \textless{}\sphinxstylestrong{notify}\textgreater{} from Q and P and sets \sphinxstyleemphasis{notified\textless{}R\textgreater{}} to true. Since requests\textless{}R\textgreater{} = 0. It sends \textless{}\sphinxstylestrong{grant}\textgreater{} to P and R and awaits \textless{}\sphinxstylestrong{ack}\textgreater{} from them. (See Figure 4)

\item {} 
\sphinxAtStartPar
P receives \textless{}\sphinxstylestrong{grant}\textgreater{} from Q and sets \sphinxstyleemphasis{requests\textless{}P\textgreater{}} to 1. P sends \textless{}\sphinxstylestrong{ack}\textgreater{} to Q. (See Figure 4)

\item {} 
\sphinxAtStartPar
Q receives \textless{}\sphinxstylestrong{grant}\textgreater{} from R and sets \sphinxstyleemphasis{requests\textless{}Q\textgreater{}} to 0. It first sends \textless{}\sphinxstylestrong{ack}\textgreater{} to R, and then sends \textless{}\sphinxstylestrong{grant}\textgreater{} to P. (See Figure 5)

\item {} 
\sphinxAtStartPar
P receives \textless{}\sphinxstylestrong{grant}\textgreater{} from Q and sets \sphinxstyleemphasis{requests\textless{}P\textgreater{}} to 0. It sends \textless{}\sphinxstylestrong{ack}\textgreater{} to Q. (See Figure 6)

\item {} 
\sphinxAtStartPar
R receives \textless{}\sphinxstylestrong{ack}\textgreater{} from Q and P, it sends \textless{}\sphinxstylestrong{done}\textgreater{} to P. (See Figure 6)

\item {} 
\sphinxAtStartPar
Q receives \textless{}\sphinxstylestrong{ack}\textgreater{} from P, it sends \textless{}\sphinxstylestrong{done}\textgreater{} to P. (See Figure 6)

\item {} 
\sphinxAtStartPar
P receives \textless{}\sphinxstylestrong{done}\textgreater{} from Q and R, checks the value of \sphinxstyleemphasis{free\textless{}P\textgreater{}} and concludes that it is not deadlocked.

\end{enumerate}


\subsection{Correctness}
\label{\detokenize{docs/BrachaToueg/algorithm:correctness}}
\sphinxAtStartPar
Deadlock is detected if and only if the initiator node belongs to a cycle of the WFG. Every process forwards the message to each of its successors in the WFG. Therefore, in a bounded number of steps, the initiator process i receives the message and detects that it is deadlocked. If the initiator does not belong to the cycle, then it will never receive its own message, so deadlock will not be detected. \sphinxcite{docs/BrachaToueg/algorithm:ghosh2015}


\subsection{Complexity}
\label{\detokenize{docs/BrachaToueg/algorithm:complexity}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Time Complexity:} The {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection}}}} has time complexity of 4 * d hops, where d is the diameter of a given WFG. \sphinxcite{docs/BrachaToueg/algorithm:kshemkalyani1994}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Message Complexity:} In thhe {\hyperref[\detokenize{docs/BrachaToueg/algorithm:brachatouegdeadlockdetectionalgorithm}]{\sphinxcrossref{\DUrole{std,std-ref}{Bracha\sphinxhyphen{}Toueg Deadlock Detection}}}}, at most four messages are sent over each edge, i.e., at most a total of 4e mes\sphinxhyphen{} sages are sent. The size of each message is a small constant number of bits. A node v of degree k needs o(k) bits of local storage, and spends o(k) time in local computation. \sphinxcite{docs/BrachaToueg/algorithm:bracha1987}

\end{enumerate}

\sphinxstepscope


\section{Implementation, Results and Discussion}
\label{\detokenize{docs/BrachaToueg/results:implementation-results-and-discussion}}\label{\detokenize{docs/BrachaToueg/results::doc}}

\subsection{Implementation and Methodology}
\label{\detokenize{docs/BrachaToueg/results:implementation-and-methodology}}
\sphinxAtStartPar
We utilized the Python (version 3.12) scripting language and the Ad\sphinxhyphen{}Hoc Computing (adhoccomputing) library while implementing the Bracha\sphinxhyphen{}Toueg Detection Algorithm. We also employed the networkx library to generate various network topologies and the matplotlib library to visualize them. Each component in the topology can be the initiator for the deadlock detection algorithm. We implemented a function for which we can simulate processes requesting resources from one another. This function “send\_request\_to\_component” is called for processes before starting the deadlock detection algorithm by sending “DETECTDEADLOCK” event to the initiator process. Once we started the deadlock detection algorithm, we first take the Lai\sphinxhyphen{}Yang snapshot of the initiator process. We are only interested in the exchanged “REQUEST” messages for deadlock detection, so we ignore other types of exchanged messages. Once the initiator process completes the Lai\sphinxhyphen{}Yang snapshot algorithm, it uses its previously recorded state to understand what processes it is waiting to receive resources and what processes waiting for it to grant resources. This means that, the initiator process computes a WFG graph for itself. Then, it continues with notifying the processes in “OUT” and waits for receiving DONE message from all of them. Once it receives DONE from all processes in OUT, it checks whether it is deadlocked by looking at its local variable “free”. An importing to mention here is that, the grant procedure is embedded inside the notify. This enables a process to need to receive ACKNOWLEDGE messages from all processes in IN, before sending any “DONE” messages.

\sphinxAtStartPar
If there is a cyclic dependency in the WFG, then we should expect that, the variable “free” for the initiator process can never be True. If there is no cyclic dependency in the WFG involving the initiator process, than we see that the variable “free” becomes True because the initiator process is able to grant some resources to other processes.

\sphinxAtStartPar
We implemented the Lai\sphinxhyphen{}Yang Snapshot Algorithm and the Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm by employing the pseudocode descriptions given by in \sphinxcite{docs/BrachaToueg/algorithm:fokking2013}. We used the same message types given in the descriptions to achieve the message passing between the components. The make the component who is the initiator of the basic algorithm send itself “DETECTDEADLOCK” message to trigger the algorithm. Depending on whether the initiator process can set the variable “free” to True, the algorithm detects the deadlock. An important note here is that, waiting for DONE and ACKNOWLEDGE messages should not prevent receiving and sending GRANT and NOTIFY messages. Therefore, we increased the number of threads executing in a component to 3 to reflect the asynchronous wait operations.


\subsection{Results}
\label{\detokenize{docs/BrachaToueg/results:results}}
\sphinxAtStartPar
We designed two distinct scenarios to evaluate the message complexity of the Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm. For the first scenario, we considered ring topologies with node counts as deadlock occurrence is guaranteed once each node passes a request to one of its neighbors in the same direction. In this scheme, the network topology guarantees that every node in the topology is part of the deadlock as well. Once each component sends a request to its neighbor, we start executing the algorithm through the initiator of the topology. After that, we measure the time elapsed until the initiator component detects the deadlock in the distributed system. Table 1 presents the elapsed time along with the number of control message components exchanged while running the algorithm. Note that we do not include the control messages of the Lai\sphinxhyphen{}Yang snapshot algorithm as it is not part of the deadlock detection algorithm.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Message Complexity Analysis of Deadlock Detection Algorithm on a Ring Topology}\label{\detokenize{docs/BrachaToueg/results:id2}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{25}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Node Count
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Number of Exchanged Control Messages
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Time Elapsed Until Detection
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
5
&
\sphinxAtStartPar
12
&
\sphinxAtStartPar
0.5193710327148438
\\
\sphinxhline
\sphinxAtStartPar
10
&
\sphinxAtStartPar
22
&
\sphinxAtStartPar
0.10675311088562012
\\
\sphinxhline
\sphinxAtStartPar
20
&
\sphinxAtStartPar
42
&
\sphinxAtStartPar
0.11047983169555664
\\
\sphinxhline
\sphinxAtStartPar
50
&
\sphinxAtStartPar
72
&
\sphinxAtStartPar
4.122158050537109
\\
\sphinxhline
\sphinxAtStartPar
100
&
\sphinxAtStartPar
123
&
\sphinxAtStartPar
7.982053995132446
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The plots below shows the relationship between the node count in the network with the time elapsed until detection and number of exchanged control messages.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxtableatstartofbodyhook\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=511\sphinxpxdimen,height=307\sphinxpxdimen]{{number_exchanged_messages}.png}
\sphinxfigcaption{The Relationship Between Node Count and Number Of Exchanged Messages}\label{\detokenize{docs/BrachaToueg/results:id3}}\end{sphinxfigure-in-table}\relax
&\begin{sphinxfigure-in-table}
\centering
\capstart
\noindent\sphinxincludegraphics[width=511\sphinxpxdimen,height=307\sphinxpxdimen]{{time_elapsed}.png}
\sphinxfigcaption{The Relationship Between the Node Count and the Elapsed Time}\label{\detokenize{docs/BrachaToueg/results:id4}}\end{sphinxfigure-in-table}\relax
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
In the second scenario, we considered a complete topology of 10 nodes. In such a topology, there are different cycles with different participating nodes. Before executing the algorithm, we found random cycles with 9, 8, 7, 5, and 3 nodes and made each component send a request to its neighbors in the same direction. After that, we start executing the algorithm through a participating node of the cycles. Table 2 presents the time elapsed until an initiator detects the deadlock of the same cycle in the system.


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\sphinxcapstartof{table}
\sphinxthecaptionisattop
\sphinxcaption{Message Complexity Analysis of Deadlock Detection Algorithm on a Complete Topology}\label{\detokenize{docs/BrachaToueg/results:id5}}
\sphinxaftertopcaption
\begin{tabular}[t]{\X{25}{100}\X{25}{100}\X{50}{100}}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Cycles in the Topology
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Initiator Node
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Time Elapsed Until Detection
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{[}0, 2, 3, 4, 5, 6, 7, 8, 9{]}
&
\sphinxAtStartPar
7
&
\sphinxAtStartPar
0.1082148551940918
\\
\sphinxhline
\sphinxAtStartPar
{[}0, 1, 2, 3, 6, 7, 8, 9{]}
&
\sphinxAtStartPar
8
&
\sphinxAtStartPar
0.10948896408081055
\\
\sphinxhline
\sphinxAtStartPar
{[}2, 3, 4, 5, 6, 7, 8{]}
&
\sphinxAtStartPar
2
&
\sphinxAtStartPar
0.7286171913146973
\\
\sphinxhline
\sphinxAtStartPar
{[}0, 2, 4, 8, 9{]}
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0.5165529251098633
\\
\sphinxhline
\sphinxAtStartPar
{[}0, 3, 6{]}
&
\sphinxAtStartPar
6
&
\sphinxAtStartPar
0.31595897674560547
\\
\sphinxbottomrule
\end{tabular}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Discussion}
\label{\detokenize{docs/BrachaToueg/results:discussion}}
\sphinxAtStartPar
We conducted two separate experiments to analyze the message and time complexity of an algorithm. To distinguish between the experiments, we did not modify the underlying computation. Instead, we made each process send a request to one of its neighbors in the same direction. By not changing the underlying computation, we could observe the changes in elapsed time over different topologies.

\sphinxAtStartPar
During the experiments, we had to add delays between events because we observed that, in the absence of the delays, we could not see the exchange of all the messages we sent. Additionally, we simulated some processes waiting to acquire resources as requests running in our topologies to conduct experiments.

\sphinxAtStartPar
Since we were only interested in generating a Wait\sphinxhyphen{}For\sphinxhyphen{}Graph (WFG), we ignored other exchanged messages in the distributed system while taking the Lai\sphinxhyphen{}Yang Snapshot. As a result, the algorithm became heavily dependent on the custom event.

\sphinxAtStartPar
Despite the challenges, we observed that as the number of nodes participating in a cycle increased, the time it took to detect the cycle in the topology went up proportionally.

\sphinxstepscope


\section{Conclusion}
\label{\detokenize{docs/BrachaToueg/conclusion:conclusion}}\label{\detokenize{docs/BrachaToueg/conclusion::doc}}
\sphinxAtStartPar
The Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm is a reliable and adaptable solution for identifying and resolving deadlocks in distributed systems across various network topologies. We have explored the algorithm extensively, emphasizing its significance, implementation intricacies, and message complexity evaluation. Our analysis of the algorithm’s message complexity has demonstrated its efficiency and practicality. By using the ad\sphinxhyphen{}hoc computing library, we have conducted experiments that show a message complexity of O(4E), which is in line with theoretical expectations. This high efficiency makes the algorithm suitable for real\sphinxhyphen{}world distributed systems. If the algorithm is included in the ad\sphinxhyphen{}hoc computing library, anyone can use it in their research. We discussed how we implemented the request mechanism in Section 1.4.3. In future work, we could approach the issue differently and change the implementation to reflect requests as not specific events but messages that belong to the algorithm having a deadlock in the system. We also mentioned that the Lai\sphinxhyphen{}Yang Snapshot implementation only considers the specific request messages and discards others as they do not relate to deadlock detection. Another approach would be considering all kinds of messages, but not storing the messages’ contents would be more efficient and generic because what is in a message is irrelevant.

\sphinxstepscope


\chapter{Assessment Rubric}
\label{\detokenize{docs/rubric:assessment-rubric}}\label{\detokenize{docs/rubric::doc}}
\sphinxAtStartPar
Your work and documentation will be assessed based on the following list of criteria.


\section{Organization and Style}
\label{\detokenize{docs/rubric:organization-and-style}}
\sphinxAtStartPar
{[}15 points{]} The documentation states  title, author names, affiliations and date. The format follows this style?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Structure and Organization: Does the organization of the paper enhance understanding of the material? Is the flow logical with appropriate transitions between sections?

\item {} 
\sphinxAtStartPar
Technical Exposition: Is the technical material presented clearly and logically? Is the material presented at the appropriate level of detail?

\item {} 
\sphinxAtStartPar
Clarity: Is the writing clear, unambiguous and direct? Is there excessive use of jargon, acronyms or undefined terms?

\item {} 
\sphinxAtStartPar
Style: Does the writing adhere to conventional rules of grammar and style? Are the references sufficient and appropriate?

\item {} 
\sphinxAtStartPar
Length: Is the length of the paper appropriate to the technical content?

\item {} 
\sphinxAtStartPar
Illustrations: Do the figures and tables enhance understanding of the text? Are they well explained? Are they of appropriate number, format and size?

\item {} 
\sphinxAtStartPar
Documentation style: Did you follow the expected documentation style (rst or latex)?

\end{enumerate}


\section{Abstract}
\label{\detokenize{docs/rubric:abstract}}
\sphinxAtStartPar
{[}10 points{]} Does the abstract summarize the documentation?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Motivation/problem statement: Why do we care about the problem? What practical, scientific or theoretical gap is your research filling?

\item {} 
\sphinxAtStartPar
Methods/procedure/approach: What did you actually do to get your results?

\item {} 
\sphinxAtStartPar
Results/findings/product: As a result of completing the above procedure, what did you learn/invent/create? What are the main learning points?

\item {} 
\sphinxAtStartPar
Conclusion/implications: What are the larger implications  of your findings, especially for the problem/gap identified?

\end{enumerate}


\section{Introduction and the Problem}
\label{\detokenize{docs/rubric:introduction-and-the-problem}}
\sphinxAtStartPar
{[}15 points{]} The problem section must be specific. The title of the section must indicate your problem. Do not use generic titles.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Is the problem clearly stated?

\item {} 
\sphinxAtStartPar
Is the problem practically important?

\item {} 
\sphinxAtStartPar
What is the purpose of the study?

\item {} 
\sphinxAtStartPar
What is the hypothesis?

\item {} 
\sphinxAtStartPar
Are the key terms defined?

\end{enumerate}


\section{Background and Related Work}
\label{\detokenize{docs/rubric:background-and-related-work}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation present the background and related work in separate sections.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Are the cited sources pertinent to the study?

\item {} 
\sphinxAtStartPar
Is the review too broad or too narrow?

\item {} 
\sphinxAtStartPar
Are the references/citation recent or appropriate?

\item {} 
\sphinxAtStartPar
Is there any evidence of bias?

\end{enumerate}


\section{Implementation and Methodology}
\label{\detokenize{docs/rubric:implementation-and-methodology}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation present the design of the study.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
What research methodology was used?

\item {} 
\sphinxAtStartPar
Was it a replica study or an original study?

\item {} 
\sphinxAtStartPar
What measurement tools were used?

\item {} 
\sphinxAtStartPar
How were the procedures structured and the implementation done?

\item {} 
\sphinxAtStartPar
Were extensive exprimentations conducted providing not only means but also confidence intervals?

\item {} 
\sphinxAtStartPar
What are the assessed parameters and were they adequate?

\item {} 
\sphinxAtStartPar
How was sampling and measurement performed?

\end{enumerate}


\section{Analysis and Discussion}
\label{\detokenize{docs/rubric:analysis-and-discussion}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation present the analysis?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Did you collected enough and adequate data for analysis?

\item {} 
\sphinxAtStartPar
How was data analyzed?

\item {} 
\sphinxAtStartPar
Was data qualitative or quantitative?

\item {} 
\sphinxAtStartPar
Did you provide main learning points based on analysis and results?

\item {} 
\sphinxAtStartPar
Did findings support the hypothesis and purpose?

\item {} 
\sphinxAtStartPar
Did you provide discussion as to the main learning points?

\item {} 
\sphinxAtStartPar
Were weaknesses and problems discussed?

\end{enumerate}


\section{Conclusion and Future Work}
\label{\detokenize{docs/rubric:conclusion-and-future-work}}
\sphinxAtStartPar
{[}15 points{]} Does the documentation state the conclusion and future work clearly?
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Are the conclusions of the study related to the original purpose?

\item {} 
\sphinxAtStartPar
Were the implications discussed?

\item {} 
\sphinxAtStartPar
Whom will the results and conclusions effect?

\item {} 
\sphinxAtStartPar
What recommendations were made at the conclusion?

\item {} 
\sphinxAtStartPar
Did you provide future work and suggestions?

\end{enumerate}

\sphinxstepscope


\chapter{Code Documentation}
\label{\detokenize{docs/BrachaToueg/code:code-documentation}}\label{\detokenize{docs/BrachaToueg/code::doc}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
{\hyperref[\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:module-BrachaToueg.BrachaToueg}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg}}}}}
&
\sphinxAtStartPar

\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\section{BrachaToueg.BrachaToueg}
\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:module-BrachaToueg.BrachaToueg}}\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:brachatoueg-brachatoueg}}\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg::doc}}\index{module@\spxentry{module}!BrachaToueg.BrachaToueg@\spxentry{BrachaToueg.BrachaToueg}}\index{BrachaToueg.BrachaToueg@\spxentry{BrachaToueg.BrachaToueg}!module@\spxentry{module}}\subsubsection*{Classes}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\sphinxthistablewithnovlinesstyle
\centering
\begin{tabulary}{\linewidth}[t]{\X{1}{2}\X{1}{2}}
\sphinxtoprule
\sphinxtableatstartofbodyhook\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}
\index{BrachaTouegComponentModel (class in BrachaToueg.BrachaToueg)@\spxentry{BrachaTouegComponentModel}\spxextra{class in BrachaToueg.BrachaToueg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg.}}\sphinxbfcode{\sphinxupquote{BrachaTouegComponentModel}}}{\sphinxparam{\DUrole{n}{componentname}}\sphinxparamcomma \sphinxparam{\DUrole{n}{componentinstancenumber}}\sphinxparamcomma \sphinxparam{\DUrole{n}{context}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{configurationparameters}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{num\_worker\_threads}\DUrole{o}{=}\DUrole{default_value}{3}}\sphinxparamcomma \sphinxparam{\DUrole{n}{topology}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{child\_conn}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{node\_queues}\DUrole{o}{=}\DUrole{default_value}{None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{channel\_queues}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
\pysigstopsignatures\index{on\_receiving\_detect\_deadlock() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_detect\_deadlock()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_detect_deadlock}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_detect\_deadlock}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method triggers the Bracha\sphinxhyphen{}Toueg Deadlock Detection Algorithm
by first taking a local snapshot of the component starting the algorithm.

\end{fulllineitems}

\index{on\_receiving\_take\_snapshot() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_take\_snapshot()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_take_snapshot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_take\_snapshot}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method triggers the Lai\sphinxhyphen{}Yang Snapshot Algorithm

\end{fulllineitems}

\index{send\_request\_to\_component() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{send\_request\_to\_component()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.send_request_to_component}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{send\_request\_to\_component}}}{\sphinxparam{\DUrole{n}{component}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method sends a request to the given component in the arguments, simulating
that this process requires some resource/communication from the given component
REQUEST is part of the basic algorithm and independent of the detection algorithm.

\end{fulllineitems}

\index{on\_receiving\_request\_from\_component() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_request\_from\_component()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_request_from_component}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_request\_from\_component}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This method receives the request by comparing the process sending the request’s local snapshot and the process receiving
the request. If process sending this request has already taken the snapshot, this process also takes it. If this process
took its snapshot then, it proceeds to check the condition for termination

\end{fulllineitems}

\index{on\_receiving\_presnapshot() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_presnapshot()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_presnapshot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_presnapshot}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
The component receiving the presnapshot control message starts to take its own local snapshot.
After that, if the termination condition is satisfied, the component terminates the snapshot algorithm.

\end{fulllineitems}

\index{on\_message\_from\_bottom() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_message\_from\_bottom()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_message_from_bottom}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_message\_from\_bottom}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This function processes the message from top events by calling related
functions according to the message’s header.

\end{fulllineitems}

\index{take\_snapshot() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{take\_snapshot()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.take_snapshot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{take\_snapshot}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This method takes a local snapshot of the component after sending presnapshot messages to all its outgoing
channels by storing \sphinxstyleemphasis{self.incoming\_channels}, \sphinxstyleemphasis{self.outgoing\_channels}, \sphinxstyleemphasis{self.state} and \sphinxstyleemphasis{self.counter}.

\end{fulllineitems}

\index{terminate\_snapshot() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{terminate\_snapshot()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.terminate_snapshot}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{terminate\_snapshot}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This method notifies the component by calling the deadlock detection algorithm
to proceed with since the WFG is computed.

\end{fulllineitems}

\index{check\_termination\_condition() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{check\_termination\_condition()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.check_termination_condition}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{check\_termination\_condition}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
This function compares the number of incoming and outgoing messages of a given component
with its incoming message set length and reaches a conclusion about the algorithm termination

\end{fulllineitems}

\index{generate\_message() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{generate\_message()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.generate_message}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate\_message}}}{\sphinxparam{\DUrole{n}{messagetype}}\sphinxparamcomma \sphinxparam{\DUrole{n}{messagefrom}}\sphinxparamcomma \sphinxparam{\DUrole{n}{messageto}}\sphinxparamcomma \sphinxparam{\DUrole{n}{payload}}}{}
\pysigstopsignatures
\sphinxAtStartPar
This function generates a GenericMessage object given the type of the message,
the payload of the message and the message source and destination

\end{fulllineitems}

\index{notify() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{notify()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.notify}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{notify}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Process sends notify to all its outgoing messages and if it does not wait for
any resources, it starts granting the resources. After receiving DONE messages
from its outgoing channels, it checks the value of free and decides whether it
is deadlocked.

\end{fulllineitems}

\index{grant() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{grant()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.grant}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{grant}}}{}{}
\pysigstopsignatures
\sphinxAtStartPar
Process that is able to grant resource to its incoming channels becomes a free process and
waits for ACKNOWLEDGE message from its incoming channels before proceeding.

\end{fulllineitems}

\index{on\_receiving\_notify() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_notify()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_notify}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_notify}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Process receiving the notify message notifies its outgoing components
if it is not notified earlier. After that it sends DONE message to the
process sending the notify message.

\end{fulllineitems}

\index{on\_receiving\_grant() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_grant()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_grant}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_grant}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Process receiving the grant message grants resources to its incoming channels
if it does not wait for any resources. After that, it sends ACKNOWLEDGE message
to the process granting the resource to it.

\end{fulllineitems}

\index{on\_receiving\_acknowledge() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_acknowledge()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_acknowledge}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_acknowledge}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\end{fulllineitems}

\index{on\_receiving\_done() (BrachaToueg.BrachaToueg.BrachaTouegComponentModel method)@\spxentry{on\_receiving\_done()}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegComponentModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegComponentModel.on_receiving_done}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{on\_receiving\_done}}}{\sphinxparam{\DUrole{n}{eventobj}}}{}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{BrachaTouegEventTypes (class in BrachaToueg.BrachaToueg)@\spxentry{BrachaTouegEventTypes}\spxextra{class in BrachaToueg.BrachaToueg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegEventTypes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg.}}\sphinxbfcode{\sphinxupquote{BrachaTouegEventTypes}}}{\sphinxparam{\DUrole{n}{value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names=\textless{}not given\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{*values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{module=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qualname=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{type=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start=1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary=None}}}{}
\pysigstopsignatures\index{DETECTDEADLOCK (BrachaToueg.BrachaToueg.BrachaTouegEventTypes attribute)@\spxentry{DETECTDEADLOCK}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegEventTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegEventTypes.DETECTDEADLOCK}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{DETECTDEADLOCK}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}DETECTDEADLOCK\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{BrachaTouegMessageTypes (class in BrachaToueg.BrachaToueg)@\spxentry{BrachaTouegMessageTypes}\spxextra{class in BrachaToueg.BrachaToueg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegMessageTypes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg.}}\sphinxbfcode{\sphinxupquote{BrachaTouegMessageTypes}}}{\sphinxparam{\DUrole{n}{value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names=\textless{}not given\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{*values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{module=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qualname=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{type=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start=1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary=None}}}{}
\pysigstopsignatures\index{REQUEST (BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute)@\spxentry{REQUEST}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegMessageTypes.REQUEST}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{REQUEST}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}REQUEST\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{NOTIFY (BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute)@\spxentry{NOTIFY}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegMessageTypes.NOTIFY}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{NOTIFY}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}NOFIFY\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{DONE (BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute)@\spxentry{DONE}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegMessageTypes.DONE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{DONE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}DONE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{GRANT (BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute)@\spxentry{GRANT}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegMessageTypes.GRANT}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{GRANT}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}GRANT\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}

\index{ACKNOWLEDGE (BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute)@\spxentry{ACKNOWLEDGE}\spxextra{BrachaToueg.BrachaToueg.BrachaTouegMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.BrachaTouegMessageTypes.ACKNOWLEDGE}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{ACKNOWLEDGE}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}ACKNOWLEDGE\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{LaiYangEventTypes (class in BrachaToueg.BrachaToueg)@\spxentry{LaiYangEventTypes}\spxextra{class in BrachaToueg.BrachaToueg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.LaiYangEventTypes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg.}}\sphinxbfcode{\sphinxupquote{LaiYangEventTypes}}}{\sphinxparam{\DUrole{n}{value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names=\textless{}not given\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{*values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{module=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qualname=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{type=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start=1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary=None}}}{}
\pysigstopsignatures\index{TAKESNAPSHOT (BrachaToueg.BrachaToueg.LaiYangEventTypes attribute)@\spxentry{TAKESNAPSHOT}\spxextra{BrachaToueg.BrachaToueg.LaiYangEventTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.LaiYangEventTypes.TAKESNAPSHOT}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{TAKESNAPSHOT}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}TAKESNAPSHOT\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{LaiYangMessageTypes (class in BrachaToueg.BrachaToueg)@\spxentry{LaiYangMessageTypes}\spxextra{class in BrachaToueg.BrachaToueg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.LaiYangMessageTypes}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg.}}\sphinxbfcode{\sphinxupquote{LaiYangMessageTypes}}}{\sphinxparam{\DUrole{n}{value}}\sphinxparamcomma \sphinxparam{\DUrole{n}{names=\textless{}not given\textgreater{}}}\sphinxparamcomma \sphinxparam{\DUrole{n}{*values}}\sphinxparamcomma \sphinxparam{\DUrole{n}{module=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{qualname=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{type=None}}\sphinxparamcomma \sphinxparam{\DUrole{n}{start=1}}\sphinxparamcomma \sphinxparam{\DUrole{n}{boundary=None}}}{}
\pysigstopsignatures\index{PRESNAPSHOT (BrachaToueg.BrachaToueg.LaiYangMessageTypes attribute)@\spxentry{PRESNAPSHOT}\spxextra{BrachaToueg.BrachaToueg.LaiYangMessageTypes attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.LaiYangMessageTypes.PRESNAPSHOT}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{PRESNAPSHOT}}\sphinxbfcode{\sphinxupquote{\DUrole{w}{ }\DUrole{p}{=}\DUrole{w}{ }\textquotesingle{}PRESNAPSHOT\textquotesingle{}}}}
\pysigstopsignatures
\end{fulllineitems}


\end{fulllineitems}

\index{SnapshotState (class in BrachaToueg.BrachaToueg)@\spxentry{SnapshotState}\spxextra{class in BrachaToueg.BrachaToueg}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:BrachaToueg.BrachaToueg.SnapshotState}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{ }}}\sphinxcode{\sphinxupquote{BrachaToueg.BrachaToueg.}}\sphinxbfcode{\sphinxupquote{SnapshotState}}}{\sphinxparam{\DUrole{n}{snapshot\_recorded}}\sphinxparamcomma \sphinxparam{\DUrole{n}{counter}}\sphinxparamcomma \sphinxparam{\DUrole{n}{state}}\sphinxparamcomma \sphinxparam{\DUrole{n}{outgoing\_channels}}\sphinxparamcomma \sphinxparam{\DUrole{n}{incoming\_channels}}}{}
\pysigstopsignatures
\end{fulllineitems}


\begin{sphinxadmonition}{attention}{Attention:}
\sphinxAtStartPar
For RST details, please refer to \sphinxhref{https://docutils.sourceforge.io/rst.html}{reStructuredText Documentation}.
\end{sphinxadmonition}


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\sphinxAtStartPar
\DUrole{xref,std,std-ref}{search}

\end{itemize}

\begin{sphinxthebibliography}{Kshemkal}
\bibitem[Fokking2013]{docs/BrachaToueg/algorithm:fokking2013}
\sphinxAtStartPar
Wan Fokkink, Distributed Algorithms An Intuitive Approach, The MIT Press Cambridge, Massachusetts London, England, 2013
\bibitem[Bracha1987]{docs/BrachaToueg/algorithm:bracha1987}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{6}
\item {} 
\sphinxAtStartPar
Bracha and S. Toeug, “Distributed Deadlock detection”. Distributed Comput., vol. 2, pp. 127\sphinxhyphen{}138, 1987

\end{enumerate}
\bibitem[Kshemkalyani2008]{docs/BrachaToueg/algorithm:kshemkalyani2008}
\sphinxAtStartPar
Ajay D. Kshemkalyani, Mukesh Singhal, Distributed Computing: Principles, Algorithms and Systems, Cambridge Univeristy Press, New York, USA, 2008
\bibitem[Kshemkalyani1994]{docs/BrachaToueg/algorithm:kshemkalyani1994}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\item {} \begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumii}{enumiii}{}{.}%
\setcounter{enumii}{3}
\item {} 
\sphinxAtStartPar
Kshemkalyani and M. Singhal, “Efficient detection and resolution of generalized distributed deadlocks,” in IEEE Transactions on Software Engineering, vol. 20, no. 1, pp. 43\sphinxhyphen{}54, Jan. 1994,

\end{enumerate}

\end{enumerate}
\bibitem[Knapp1987]{docs/BrachaToueg/algorithm:knapp1987}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{4}
\item {} 
\sphinxAtStartPar
Knapp, “Deadlock Detection in Distributed Databases”, ACM Computing Surveys, Volume 19, Issue 4, pp 303\sphinxhyphen{}328, 1987

\end{enumerate}
\bibitem[Ghosh2015]{docs/BrachaToueg/algorithm:ghosh2015}\begin{enumerate}
\sphinxsetlistlabels{\Alph}{enumi}{enumii}{}{.}%
\setcounter{enumi}{18}
\item {} 
\sphinxAtStartPar
Ghosh, “Distributed Systems: An Algorithmic Approach, 2nd Edition”, CRC Press pp. 184, 2015

\end{enumerate}
\end{sphinxthebibliography}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{b}
\item\relax\sphinxstyleindexentry{BrachaToueg.BrachaToueg}\sphinxstyleindexpageref{docs/BrachaToueg/generated/BrachaToueg.BrachaToueg:\detokenize{module-BrachaToueg.BrachaToueg}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}